# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014, moco_beta
# This file is distributed under the same license as the Redis Documentation (Japanese) package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Redis Documentation (Japanese) 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-07-31 23:30+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/topics/data-types-intro.rst:2
# b9ad75c1c3b54c87af3066e64e8d6c89
msgid "An introduction to Redis data types and abstractions"
msgstr ""

#: ../../source/topics/data-types-intro.rst:4
# c0ee52c06ce443ee9f455c9e96e0ffc8
msgid "Redis is not a *plain* key-value store, actually it is a *data structures server*, supporting different kind of values. What this means is that, while in traditional key-value stores you associated string keys to string values, in Redis the value is not limited to a simple string, but can also hold more complex data structures. The following is the list of all the data structures supported by Redis, which will be covered separately in this tutorial:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:12
# 85cb7399df6f4eaa9c6248ce5eb083d2
msgid "Binary-safe strings."
msgstr ""

#: ../../source/topics/data-types-intro.rst:13
# 20606d3191ca4669a9901114e193474c
msgid "Lists: collections of string elements sorted according to the order of insertion. They are basically *linked lists*."
msgstr ""

#: ../../source/topics/data-types-intro.rst:15
# c0b4785ead494663b61bfa2001fd9fdc
msgid "Sets: collections of unique, unsorted string elements."
msgstr ""

#: ../../source/topics/data-types-intro.rst:16
# 7e27ed799f5143e9b9794943ade21db5
msgid "Sorted sets, similar to Sets but where every string element is associated to a floating number value, called *score*. The elements are always taken sorted by their score, so unlike Sets it is possible to retrieve range of elements (for example you may aks: give me the top 10, or the bottom 10)."
msgstr ""

#: ../../source/topics/data-types-intro.rst:21
# 5d1058147ebb484f9f8c5a03f5717331
msgid "Hashes, which are maps composed of fields associated with values. Both the field and the value are strings. This are very similary to Ruby or Python hashes."
msgstr ""

#: ../../source/topics/data-types-intro.rst:24
# e7797f8ea0a04452b71b10af38e70525
msgid "Bit arrays: it is possible, usign special commands, to handle String values like array of bits: you can set and clear individual bits, count all the bits set to 1, find the first set or unset bit, and so forth."
msgstr ""

#: ../../source/topics/data-types-intro.rst:28
# 915937c6ac5f48f38eb8198e63f4cab2
msgid "HyperLogLogs: this is a probabilistic data structure which is used in order to estimate the cardinality of a set. Don't be scared, it is simpler than it seems... See later in the HyperLogLog section of this tutorial."
msgstr ""

#: ../../source/topics/data-types-intro.rst:33
# b37d6781a2fc4d39958bf811bb1266e6
msgid "It's not always trivial to grasp how these data types work and what to use in order to solve a given problem from the `command reference </commands>`__, so this document is a crash course to Redis data types and their most used patterns."
msgstr ""

#: ../../source/topics/data-types-intro.rst:38
# c22582fcd1d74d65b27326f472bdd29d
msgid "For all the examples we'll use the ``redis-cli`` utility, that's a simple but handy command line utility to issue commands against the Redis server."
msgstr ""

#: ../../source/topics/data-types-intro.rst:43
# ec19b977f6f9488aaff4484b9da0c693
msgid "Redis keys"
msgstr ""

#: ../../source/topics/data-types-intro.rst:45
# 8d065bc5dc9440cdbeb228e05bed8212
msgid "Redis keys are binary safe, this means that you can use any binary sequence as a key, from a string like \"foo\" to the content of a JPEG file. The empty string is also a valid key."
msgstr ""

#: ../../source/topics/data-types-intro.rst:49
# 1a52bc44c1f8424f82212f9a4372279a
msgid "A few other rules about keys:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:51
# 72ef9a3ca7c14065ae942689b2a742b3
msgid "Too long keys are not a good idea, for instance a key of 1024 bytes is not a good idea not only memory-wise, but also because the lookup of the key in the dataset may require several costly key-comparisons. Even when the task at hand is to match the existence of a big value, to resort to hashing it (for example with SHA1) is a better idea, especially from the point of view of memory and bandwidth."
msgstr ""

#: ../../source/topics/data-types-intro.rst:57
# d5182aeea57448e6800189258d7cfa96
msgid "Too short keys are often not a good idea. There is little point in writing \"u1000flw\" as key if you can write instead \"user:1000:followers\", the latter is more readable and the added space is little compared to the space used by the key object itself and the value object. However it is not possible to deny that short keys will consume a bit less memory. Your job is to find the right balance."
msgstr ""

#: ../../source/topics/data-types-intro.rst:64
# 73c233adaa6c4819bffc21a5d432b099
msgid "Try to stick with a schema. For instance \"object-type:id\" can be a nice idea, like in \"user:1000\". Dots or dashes are often used for multi-words fields, like in \"comment:1234:reply.to\" or \"comment:1234:reply-to\"."
msgstr ""

#: ../../source/topics/data-types-intro.rst:68
# 12323bd8707747a0803d81a0cc79955c
msgid "The maximum allowed key size is 512 MB."
msgstr ""

#: ../../source/topics/data-types-intro.rst:71
# 14f19a92534749b5a367eb06354ea09b
msgid "Redis Strings"
msgstr ""

#: ../../source/topics/data-types-intro.rst:73
# 38d5127a568a49578569c3f593114576
msgid "The Redis String type is the simplest type of value you can associate to a Redis key. It is the only data type in Memcached, so it is also very natural for newcomers to use it in Redis."
msgstr ""

#: ../../source/topics/data-types-intro.rst:77
# 7a003fe53d9f4e5383279d742d3d00b2
msgid "Since Redis keys are strings, when we use the string type as a value too, we are mapping a string to another string. The string data type is useful for a number of use cases, like caching HTML fragments or pages."
msgstr ""

#: ../../source/topics/data-types-intro.rst:81
# 00bf8bcfab60428c8a2e12b567ac29d7
msgid "Let's play a bit with the string type, using ``redis-cli`` (all the examples will be performed via ``redis-cli`` in this tutorial)."
msgstr ""

#: ../../source/topics/data-types-intro.rst:91
# bc93397df6c5415493c4aff206c13b67
msgid "As you can see using the ``SET`` and the ``GET`` commands are the way we set and retrieve a string value. Note that ``SET`` will replace any existing value stored already into the key, in case the key already exists, even if the key is associated with a non-string value. So ``SET`` performs an assignment."
msgstr ""

#: ../../source/topics/data-types-intro.rst:97
# 22889718fe9745f49859464a5a2869c3
msgid "Values can be strings (including binary data) of every kind, for instance you can store a jpeg image inside a key. A value can't be bigger than 512 MB."
msgstr ""

#: ../../source/topics/data-types-intro.rst:101
# c1d0eb0bf188490dae60189759986ac6
msgid "The ``SET`` command has interesting options, that are provided as additional arguments. For example if I may ask ``SET`` to fail if the key already exists, or the exact contrary, that is, to only succeed if the key already exists:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:113
# e7ea2083c4114c02b42f178f3930ebd4
msgid "Even if strings are the basic values of Redis, there are interesting operations you can perform with them. For instance, one is atomic increment:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:128
# fad6962ed7804043b18be90cc389efa5
msgid "The `INCR </commands/incr>`__ command parses the string value as an integer, increments it by one, and finally sets the obtained value as the new value. There are other similar commands like `INCRBY </commands/incrby>`__, `DECR <commands/decr>`__ and `DECRBY </commands/decrby>`__. Internally it's always the same command, acting in a slightly different way."
msgstr ""

#: ../../source/topics/data-types-intro.rst:135
# d82c9e1c9ff7401ca3950ec655d4feff
msgid "What does it mean that INCR is atomic? That even multiple clients issuing INCR against the same key will never incur into a race condition. For instance it can never happen that client 1 read \"10\", client 2 read \"10\" at the same time, both increment to 11, and set the new value of 11. The final value will always be 12 and the read-increment-set operation is performed while all the other clients are not executing a command at the same time."
msgstr ""

#: ../../source/topics/data-types-intro.rst:143
# 29e56bec1cda40059ff95fe23cc3373d
msgid "There are a number of commands operating on strings. For example the ``GETSET`` command sets a key to a new value, returning the old value as result. You can use this command, for example, if you have a system that increments a Redis key using ``INCR`` every time your web site receives a new visit. You want to collect this information one time every hour, without losing a single increment. You can ``GETSET`` the key, assigning it the new value of \"0\" and reading the old value back."
msgstr ""

#: ../../source/topics/data-types-intro.rst:151
# f919286a8a60437ca6fc1b4a18f866be
msgid "The ability to set or retrieve the value of multiple keys in a single command is also useful for reduce latency. For this reason there are the ``MSET`` and ``MGET`` commands:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:164
# 299165324c5a4533851377e716ba4b18
msgid "When ``MSET`` is used, Redis returns an array of values."
msgstr ""

#: ../../source/topics/data-types-intro.rst:167
# 867bd38a0d6b461984a97d1efadf3c2a
msgid "Altering and querying the key space"
msgstr ""

#: ../../source/topics/data-types-intro.rst:169
# d524e9ee14fb49988fbe4e2c5da6e8c2
msgid "There are commands that are not defined on particular types, but are useful in order to interact with the space of keys, and thus, can be used with keys of any type."
msgstr ""

#: ../../source/topics/data-types-intro.rst:173
# 7ad4c4c711c24ff69ab679d15b7fa681
msgid "For example the ``EXISTS`` command returns 1 or 0 to signal if a given key exists or not in the data base, while the ``DEL`` command deletes a key and associated value, whatever the value is."
msgstr ""

#: ../../source/topics/data-types-intro.rst:188
# 941d0fac30414ef2b2f550feb802b618
msgid "From the examples you can also see how ``DEL`` itself returns 1 or 0 whatever the key was removed (it existed) or not (there was no such key with that name)."
msgstr ""

#: ../../source/topics/data-types-intro.rst:192
# 5f2ca332beee494da03decfbc3a199e5
msgid "There are many key space related commands, but the above two are the essential ones together with the ``TYPE`` command, that returns the kind of value stored at the specified key:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:208
# 363677bc62014755ac2fa0ea3a5140e7
msgid "Redis expires: keys with limited time to live"
msgstr ""

#: ../../source/topics/data-types-intro.rst:210
# 17a5c92ecc5f4118800a0fe3a1f3514b
msgid "Before to continue with more complex data structures, we need to expose another feature which works regardless of the value type, and is called **Redis expires**. Basically you can set a timeout to a key, which is, a limited time to live. When the time to live elapsed, the key is automatically destroyed, exactly like if the user called the ``DEL`` command with the key."
msgstr ""

#: ../../source/topics/data-types-intro.rst:217
# 165c632338754733992ff7d5b9358bf3
msgid "A few quick info about Redis expires:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:219
# fbe99ce3bcdf49fc9c566899393dbe93
msgid "They can be set both using seconds or milliseconds precision."
msgstr ""

#: ../../source/topics/data-types-intro.rst:220
# 00eeb816c0db4548afc298d5ead2dcd0
msgid "However the expire time resolution is always 1 millisecond."
msgstr ""

#: ../../source/topics/data-types-intro.rst:221
# 59df41dae16f412ca191f304e7104511
msgid "Information about expires are replicated and persisted on disk, the time virtually passes when your Redis server remains stopped (this means that Redis saves the date at which a key will expire)."
msgstr ""

#: ../../source/topics/data-types-intro.rst:225
# 0468cfe3971041cba934276de4818c03
msgid "Setting an expire is trivial:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:238
# ea3a8b09e640446c9f49939ec0e03c4f
msgid "The key vanished between the two ``GET`` calls, since the second call was delayed more than 5 seconds. In the example above we used ``EXPIRE`` in order to set the expire (it can also be used in order to set a different expire to a key already having one, like ``PERSIST`` can be used in order to remove the expire and make the key persistent forever). However we can also create keys with expires using other Redis commands. For example using ``SET`` options:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:253
# 89a8ca4a87034ea6b043dc9a5a206da7
msgid "The example above sets a key with the string value ``100``, having an expire of ten seconds. Later the ``TTL`` command is called in order to check the remaining time to live for the key."
msgstr ""

#: ../../source/topics/data-types-intro.rst:257
# 3a67f80621394b7b8b9dac5404e2baad
msgid "In order to set and check expires in milliseconds, check the ``PEXPIRE`` the ``PTTL`` commands, and the full list of ``SET`` options."
msgstr ""

#: ../../source/topics/data-types-intro.rst:261
# fc86a7f201284fcbbcefac6ef97d87d0
msgid "Redis Lists"
msgstr ""

#: ../../source/topics/data-types-intro.rst:263
# a19a24f915c34ffca66b241dbcd3d26e
msgid "To explain the List data type it's better to start with a little bit of theory, as the term *List* is often used in an improper way by information technology folks. For instance \"Python Lists\" are not what the name may suggest (Linked Lists), they are actually Arrays (the same data type is called Array in Ruby actually)."
msgstr ""

#: ../../source/topics/data-types-intro.rst:269
# cbde31deaf6f41d5a457432a9e46d86d
msgid "From a very general point of view a List is just a sequence of ordered elements: 10,20,1,2,3 is a list. But the properties of a List implemented using an Array are very different from the properties of a List implemented using a *Linked List*."
msgstr ""

#: ../../source/topics/data-types-intro.rst:274
# 1cc3dafc77484c45b518b2661d8b0385
msgid "Redis lists are implemented via Linked Lists. This means that even if you have millions of elements inside a list, the operation of adding a new element in the head or in the tail of the list is performed *in constant time*. Adding a new element with the ``LPUSH`` command to the head of a ten elements list is the same speed as adding an element to the head of a 10 million elements list."
msgstr ""

#: ../../source/topics/data-types-intro.rst:281
# e9bce7a5883d455fad1f07ed35107957
msgid "What's the downside? Accessing an element *by index* is very fast in lists implemented with an Array (constant time indexed access) and not so fast in lists implemented by linked lists (where the operation requires an amount of work proportional to the index of the accessed element)."
msgstr ""

#: ../../source/topics/data-types-intro.rst:287
# 19aa5646dfba4cc3a49efc1b479f2b33
msgid "Redis Lists are implemented with linked lists because for a database system it is crucial to be able to add elements to a very long list in a very fast way. Another strong advantage is, as you'll see in a moment, that Redis Lists can be taken at constant length in constant time."
msgstr ""

#: ../../source/topics/data-types-intro.rst:292
# c30d03803c7242989729ba49c76924a8
msgid "When fast access to the middle of a large collection of elements is important, there is a different data structure that can be used, called sorted sets. Sorted sets will be covered later in this tutorial."
msgstr ""

#: ../../source/topics/data-types-intro.rst:297
# cb6989f1ac7f45ba8100dc8619dbcc5c
msgid "First steps with Redis Lists"
msgstr ""

#: ../../source/topics/data-types-intro.rst:299
# d447348a7f8b406d899d42b8a6fbbadc
msgid "The ``LPUSH`` command adds a new element into a list, on the left (at the head), while the ``RPUSH`` command adds a new element into a list, on the right (at the tail). Finally the ``LRANGE`` command extracts ranges of elements from lists:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:317
# 580c161e3d3443a4ab8345be8b2595b2
msgid "Note that `LRANGE </commands/lrange>`__ takes two indexes, the first and the last element of the range to return. Both the indexes can be negative to tell Redis to start to count from the end, so -1 is the last element, -2 is the penultimate element of the list, and so forth."
msgstr ""

#: ../../source/topics/data-types-intro.rst:322
# 1a84df5adcb44271914ab8fe2978a6cd
msgid "As you can see ``RPUSH`` appended the elements on the right of the list, while the final ``LPUSH`` appended the element on the left."
msgstr ""

#: ../../source/topics/data-types-intro.rst:325
# bf75431c7a1c48118e8501c19303306c
msgid "Both commands are *variadic commands*, meaning that you are free to push multiple elements into a list in a single call:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:343
# d00ad16f38744a0c8aa027f305c6eeec
msgid "An important operation defined on Redis lists is the ability to *pop elements*. Popping elements is the operation of retrieving the element from the list, and eliminating it from the list, at the same time. You can pop elements from left and right, similarly to how you can push elements in both sides of the list:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:360
# a487b0c2009b43ba9bb1305508e5d51d
msgid "We added three elements and popped three elements, so at the end of this sequence of commands the list is empty and there are no more elements to pop. If we try to pop yet another element, this is the result we get:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:369
# e728dabd11c547b8a155717e4ad6dff9
msgid "Redis returned a NULL value to signal that there are no elements into the list."
msgstr ""

#: ../../source/topics/data-types-intro.rst:373
# e0a2994ef68f4e1382a385cf73da8291
msgid "Common use cases for lists"
msgstr ""

#: ../../source/topics/data-types-intro.rst:375
# 448850b698554906ae8e7ea348eb31c8
msgid "Lists are useful for a number of tasks, two very representative use cases are the following:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:378
# 340a2fcb58fb4b70ab208873214d83ae
msgid "Remember the latest updates posted by users into a social network."
msgstr ""

#: ../../source/topics/data-types-intro.rst:379
# cfbb36e524b24da1be656a690e37cc2c
msgid "Communication between processes, using a consumer-producer pattern where the producer pushes items into a list, and a consumer (usually a *worker*) consumes those items executing actions. Redis has special list commands to make this use case both more reliable and efficient."
msgstr ""

#: ../../source/topics/data-types-intro.rst:384
# 81bf97f21537451a992cffee44f6c251
msgid "For example both the popular Ruby libraries `resque <https://github.com/resque/resque>`__ and `sidekiq <https://github.com/mperham/sidekiq>`__ use Redis lists under the hoods in order to implement background jobs."
msgstr ""

#: ../../source/topics/data-types-intro.rst:389
# 0b3e8e6b8413438db7e913362323dcbd
msgid "The popular Twitter social network `takes the latest tweets <http://www.infoq.com/presentations/Real-Time-Delivery-Twitter>`__ posted by users into Redis lists."
msgstr ""

#: ../../source/topics/data-types-intro.rst:393
# 4eb4c4feea3b491584101fc37d8acec2
msgid "To describe a common use case step by step, imagine you want to speedup the list of the latest published photos in the home page of your photo sharing social network."
msgstr ""

#: ../../source/topics/data-types-intro.rst:397
# be00a45875824c22b9d623927aa2128f
msgid "Every time an user posts a new photo, we add its ID into a list with ``LPUSH``."
msgstr ""

#: ../../source/topics/data-types-intro.rst:399
# 916c4dfcc08540989badfac3c64ec47d
msgid "When users visit the home page, we use ``LRANGE 0 9`` in order to get the latest 10 posted items."
msgstr ""

#: ../../source/topics/data-types-intro.rst:403
# 8c3bee8af94d4cefae689beb9465910d
msgid "Capped lists"
msgstr ""

#: ../../source/topics/data-types-intro.rst:405
# 601d3beeef6b407fa95a7993e0fa2ad8
msgid "In many use cases we just want to use lists to store the *latest items*, whatever they are: social network updates, logs, or anything else."
msgstr ""

#: ../../source/topics/data-types-intro.rst:408
# 1b056fe6a31f4464b812fba5db3664dd
msgid "Redis allows to use lists as a capped collection, only remembering the latest N items and discarding all the oldest items using the ``LTRIM`` command."
msgstr ""

#: ../../source/topics/data-types-intro.rst:412
# 44d929c65e7445f7a2c1e20b23886ad0
msgid "The ``LTRIM`` command is similar to ``LRANGE``, but **instead of displaying the specified range of elements** it sets this range as the new list value. All the elements outside the given range are removed."
msgstr ""

#: ../../source/topics/data-types-intro.rst:416
# f3671e2c57904dad94b2bf9edc3ffa5e
msgid "An example will make it more clear:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:429
# c0e6a6ab813a4bb2bd53aace3c60e21a
msgid "The above ``LTRIM`` command tells Redis to take just list elements from index 0 to 2, everything else will be discarded. This makes you able to mount a very simple but useful patter, consisting in doing a List push operation + a List trim operation together in order to add a new element and discard exceeding elements:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:440
# c4fe17e6f2ec4046996c5ea6d74fadb8
msgid "The above combination of elements add a new element taking only the 1000 newest elements into the list. With ``LRANGE`` you can access the top items without any need to remember very old data."
msgstr ""

#: ../../source/topics/data-types-intro.rst:444
# baa9fcf2b1f24ad8a09added30a1f815
msgid "Note: while ``LRANGE`` is technically an O(N) command, accessing small ranges towards the head or the tail of the list, is a constant time operation."
msgstr ""

#: ../../source/topics/data-types-intro.rst:449
# 75e17917c7914b57b23508d07aff1b61
msgid "Blocking operations on lists"
msgstr ""

#: ../../source/topics/data-types-intro.rst:451
# 7bb327c1c5b0408190552b1ac58cf99c
msgid "Lists have a special feature that make them suitable to implement queues, and in general as a building block for inter process communication systems: blocking operations."
msgstr ""

#: ../../source/topics/data-types-intro.rst:455
# 020de724ae7c4e869fea3136b36edfbb
msgid "Imagine you want to push items into a list with one process, and use a different process in order to actually make some kind of work with those items. This is the usual producer / consumer setup, that can be implemented in the following simple way:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:460
# 67f3c7af04fa420db9f69c3c01c4c193
msgid "To push items into the list, producers call ``LPUSH``."
msgstr ""

#: ../../source/topics/data-types-intro.rst:461
# b106a5762c8547e6b496293608f574e8
msgid "To extract / process items from the list, consumers call ``RPOP``."
msgstr ""

#: ../../source/topics/data-types-intro.rst:463
# 27076fd0b8964f108746cd256c77fe98
msgid "However it is possible that sometimes the list is empty and there is nothing to process, so ``RPOP`` just returns NULL. So a consumer is forced to wait some time and retry again with ``RPOP``. This is called *polling*, and is not a good idea in this context because it has several drawbacks:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:469
# a3bb7cf5533042849c20ff4ce5faa6c3
msgid "Forces Redis and clients to process useless commands (all the requests when the list is empty will get no actual work done, they'll just return NULL)."
msgstr ""

#: ../../source/topics/data-types-intro.rst:472
# 30926bd31ec64e368a4bd31718a95f9e
msgid "Adds a delay to the processing of items, since after a worker receives a NULL, it waits some time. To make the delay smaller, we could wait less between calls to ``RPOP``, with the effect of aggravating more problem number 1: more useless calls to Redis."
msgstr ""

#: ../../source/topics/data-types-intro.rst:477
# 73abec532ce24b2a963da14ffe34ae7a
msgid "So Redis implements commands called ``BRPOP`` and ``BLPOP`` which are versions of ``RPOP`` and ``LPOP`` able to block if the list is empty: they'll return to the caller only when a new element is added to the list, or when an user specified timeout is reached."
msgstr ""

#: ../../source/topics/data-types-intro.rst:482
# e8f45be76b924101a77c1245bb1a9dee
msgid "This is an example of ``BRPOP`` call we could use in the worker:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:490
# 192e6fc6ac054f2a9f96d0aa8ebd9b8b
msgid "It means: \"wait for elements in the list ``tasks``, but return if after 5 seconds no element is available\"."
msgstr ""

#: ../../source/topics/data-types-intro.rst:493
# b26bf20a31784890adc0349d4e6aa3d0
msgid "Note that you can use 0 as timeout to wait forever for elements, and you can also specify multiple lists and not just one, in order to wait into multiple lists at the same time, and get notified when the first list receives an element."
msgstr ""

#: ../../source/topics/data-types-intro.rst:498
# 70a9e2d28cfa424b90ecbbff2f7262ca
msgid "A few things to note about ``BRPOP``."
msgstr ""

#: ../../source/topics/data-types-intro.rst:500
# 4bf0cbb175b74e8bb38098c207144caa
msgid "Clients are served in an ordered way: the first client that blocked waiting for a list, is served the first when an element is pushed by some other client, and so forth."
msgstr ""

#: ../../source/topics/data-types-intro.rst:503
# e767f465488c4dd58b025190ce1e9ef1
msgid "The return value is different compared to ``RPOP``: it is a two elements array since it also includes the name of the key, because ``BRPOP`` and ``BLPOP`` are able to block waiting for elements from multiple lists."
msgstr ""

#: ../../source/topics/data-types-intro.rst:507
# 94d8cc5d14a34dfcac082735febb4291
msgid "If the timeout is reached, NULL is returned."
msgstr ""

#: ../../source/topics/data-types-intro.rst:509
# bfc99e64788441f686258519d768ec4f
msgid "There are more things you should know about lists and blocking ops. We suggest you to read the following pages:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:512
# 8008ec7114194f138c838d95ddd96b1b
msgid "It is possible to build safer queues or rotating queues using ``RPOPLPUSH``."
msgstr ""

#: ../../source/topics/data-types-intro.rst:514
# 031c4717c5954951b32a5e00e808d296
msgid "There is also a blocking variant of the command, called ``BRPOPLPUSH``."
msgstr ""

#: ../../source/topics/data-types-intro.rst:518
# 7df56114610e4402a9b35db666d00f50
msgid "Automatically creation and removal of keys"
msgstr ""

#: ../../source/topics/data-types-intro.rst:520
# 4238435e6ba84cba88b4bb1f9b12213f
msgid "So far in our examples we never had to create empty lists before pushing elements, or removing empty lists when they no longer have elements inside. It is Redis care to delete keys when lists are left empty, or to create an empty list if the key does not exist and we are trying to add elements to it, for example, with ``LPUSH``."
msgstr ""

#: ../../source/topics/data-types-intro.rst:526
# d7208cd9a63e469f8b2b5356ce60ed97
msgid "This is not specific to lists, it applies to all the Redis data types composed of multiple elements, so also applies to Sets, Sorted Sets and Hashes."
msgstr ""

#: ../../source/topics/data-types-intro.rst:530
# 5d457227f80948ee8e4c97316f40a88a
msgid "Basically we can summarize the behavior with three rules:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:532
# 796eba96d1b743e695a0af7c83bcd373
msgid "When we add an element to an aggregate data type, if the target key does not exist, an empty aggregate data type is crated before adding the element."
msgstr ""

#: ../../source/topics/data-types-intro.rst:535
# 0a6a727474be418194d58591e23defa5
msgid "When we remove elements from an aggregate data type, if the value remains empty, the key is automatically destroyed."
msgstr ""

#: ../../source/topics/data-types-intro.rst:537
# 558561bc6a1b4ab8a51fd80baf1b8c66
msgid "Calling a read-only command such as ``LLEN`` (which returns the length of the list), or a write command removing elements, with an empty key, always produces the same result as if the key is holding an empty aggregate type of the type the command expects to find."
msgstr ""

#: ../../source/topics/data-types-intro.rst:542
# 4c3a9e217ec14918ac8e41036ecacada
msgid "Examples of rule 1:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:551
# 49e77513acd6428f9c2adf3c4266608e
msgid "However we can't perform operations against the wrong type of the key exists:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:563
# 90c47c50788d4525b00d54eebd7b16ca
msgid "Example of rule 2:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:580
# 0fdf7722df6847a4b995862d7ffdb12a
msgid "The key does no longer exist after all the elements are popped."
msgstr ""

#: ../../source/topics/data-types-intro.rst:582
# a9501e530c8a4e32a5aade7cb8d9eb13
msgid "Example of rule 3:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:594
# 29d177411e494123940c46c36f79a529
msgid "Redis Hashes"
msgstr ""

#: ../../source/topics/data-types-intro.rst:596
# d6c908c19cc84afdbe38a9bb3ae11e66
msgid "Redis hashes look like exactly how you expect an \"hash\" to look like:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:614
# 2eb60e30806148e2b79e77403b4ab6e3
msgid "It is just a set of fields-values pairs. While hashes are handy to represent *objects*, actually the number of fields you can put inside an hash has no practical limits if not available memory, so you can use hashes in many different ways inside your application."
msgstr ""

#: ../../source/topics/data-types-intro.rst:619
# ca6fdb70dd7a4b0ab95af4918854a494
msgid "The command ``HMSET`` sets multiple fields of the hash, while ``HGET`` retrieves a single field. ``HMGET`` is similar to ``HGET`` but returns an array of values:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:630
# 31c85ca0e55f4f28b5a22ec4f38719fa
msgid "There are commands that are able to perform operations on individual fields as well, like ``HINCRBY``:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:640
# 685b13a0e31a4b429f4acdad79a0bfa6
msgid "You can find the `full list of hash commands in the documentation <http://redis.io/commands#hash>`__."
msgstr ""

#: ../../source/topics/data-types-intro.rst:643
# aa0b5697955f4c4aa287310a4b662a2b
msgid "It is worth to note that small hashes (a few elements, not too big values) are encoded in special way in memory that make them very memory efficient."
msgstr ""

#: ../../source/topics/data-types-intro.rst:648
# 35d17ce3a620401d968a3cb293e56ab6
msgid "Redis Sets"
msgstr ""

#: ../../source/topics/data-types-intro.rst:650
# c213e030d75641f48df391a68f4b3f7d
msgid "Redis Sets are unordered collections of strings. The ``SADD`` command adds new elements to a set. It's also possible to do a number of other operations against sets like testing if a given element already exists, performing the intersection, union or difference between multiple sets and so forth."
msgstr ""

#: ../../source/topics/data-types-intro.rst:665
# 1a29b4290cb743aa9749c8dfcef61052
msgid "I added three elements to my set and told Redis to return back all the elements. As you can see they are not sorted, Redis is free to return the elements in any order at every call, since there is no contract with the user about elements ordering."
msgstr ""

#: ../../source/topics/data-types-intro.rst:670
# 42d6f60082cd458bbdb524cafef28008
msgid "We have commands to test for membership. Does a given element exists?"
msgstr ""

#: ../../source/topics/data-types-intro.rst:679
# 4d68ee2afae4428aa2f113e77bacb5a1
msgid "\"3\" is a member of the set, while \"30\" is not."
msgstr ""

#: ../../source/topics/data-types-intro.rst:681
# 94651bb853ae4819b167e0aef8deca89
msgid "Sets are good for expressing relations between objects. For instance we can easily use sets in order to implement tags."
msgstr ""

#: ../../source/topics/data-types-intro.rst:684
# 8e3808c249ce4e7e986655656a912d77
msgid "A simple way to model this problem is to have a set for every object we want to tag. The set contains the IDs of the tags associated with the object."
msgstr ""

#: ../../source/topics/data-types-intro.rst:688
# 01c41e5477db43e7b7b839045e6486bb
msgid "Imagine we want to tag news. If our news ID 1000 is tagged with tag 1,2,5 and 77, we can have one set associating our tag IDs with the news:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:696
# f03464f857ca41a9b68a20e829985566
msgid "However sometimes I may want to have the inverse relation as well: the list of all the news tagged with a given tag:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:710
# eeb51ac7cf5f4e53ae476f64e2b79693
msgid "To get all the tags for a given object is trivial:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:720
# b9da7d9d322b4e7da0284f062282164c
msgid "Note: in the example we assume you have another data structure, for example a Redis hash, which maps tag IDs to tag names."
msgstr ""

#: ../../source/topics/data-types-intro.rst:723
# 9ec65dbbef9b400da513de1e6f98c119
msgid "There are other non trivial operations that are still easy to implement using the right Redis commands. For instance we may want a list of all the objects with the tags 1, 2, 10, and 27 together. We can do this using the ``SINTER`` command, that performs the intersection between different sets. We can just use:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:734
# 0ee416712e0244b8bbcc6661227ce39e
msgid "Intersection is not the only operation performed, you can also perform unions, difference, extract a random element, and so forth."
msgstr ""

#: ../../source/topics/data-types-intro.rst:737
# d036b23707324dc4913b20c8c5b921f0
msgid "The command to extract an element is called ``SPOP``, and is handy to model certain problems. For example in order to implement a web-based poker game, you may want to represent your deck into a set. Imagine we use a one-char prefix for (C)lubs, (D)iamonds, (H)earts, (S)pades."
msgstr ""

#: ../../source/topics/data-types-intro.rst:750
# 2aed2a3de4524f0f9ba0c8b5e1faeddb
msgid "Now we want to provide each player with 5 cards. The ``SPOP`` command removes a random element, returning it to the client, so it is the perfect operation in this case."
msgstr ""

#: ../../source/topics/data-types-intro.rst:754
# 7bb06783a87d4b0caec8406dbc889169
msgid "However if we call it against our deck directly, in the next play of the game we'll need to populate the deck of cards again, which may not be ideal. So to start, we can make a copy of the set stored in the ``deck`` key, into the ``game:1:deck`` key."
msgstr ""

#: ../../source/topics/data-types-intro.rst:759
# 96daaa0042334ac6a9c55cdd64e3435e
msgid "This is accomplished using ``SUNIONSTORE``, which normally performs the intersection between multiple sets, and stores the result into anther set. However the intersection of a single set, is itself, so I can copy my deck with:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:769
# 5b5ae60d7dde4df8b4cd59c282f08187
msgid "Now I'm ready to provide the first player with its five cards:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:784
# 2be2d5bb91ae40f9ad4083ef621474d3
msgid "One pair of jacks, not great..."
msgstr ""

#: ../../source/topics/data-types-intro.rst:786
# ff07f1476d024a41a28df3ff8e903dcc
msgid "It is a good time to introduce the set command that provides the number of elements inside a set. This is often called *cardinality of a set* in the context of set theory, so the Redis command is called ``SCARD``."
msgstr ""

#: ../../source/topics/data-types-intro.rst:795
# 4bfaae8121764988a30cb55dc6d79bbd
msgid "The math works: 52 - 5 = 47."
msgstr ""

#: ../../source/topics/data-types-intro.rst:797
# 78f8d0c0ac734315b3af378f4201711f
msgid "When you need to just get random elements without removing them from the set, there is the ``SRANDMEMBER`` command suitable for the task. It also features the ability to return both repeating and non-repeating elements."
msgstr ""

#: ../../source/topics/data-types-intro.rst:803
# 70d72f5afb2044aaaf3b5b606989f96b
msgid "Redis Sorted sets"
msgstr ""

#: ../../source/topics/data-types-intro.rst:805
# f62c44aaa1c640b58948090d0a7945d3
msgid "Sorted sets are a data type which is similar to a mix between asSet and an hash. Like sets, sorted sets are composed of unique, non-repeating string elements, so in some sense a sorted set is a set as well."
msgstr ""

#: ../../source/topics/data-types-intro.rst:809
# 9c919c4dc4ec4432948970a190fcbfb1
msgid "However while elements inside sets are not ordered, every element in a sorted set is associated with a floating point value, called *the score* (this is why the type is also similar to an hash, since every element is mapped to a value)."
msgstr ""

#: ../../source/topics/data-types-intro.rst:814
# a824422112094fbca66dab52a76429e8
msgid "Moreover, elements in a sorted sets are *taken in order* (so they are not ordered on request, order is a peculiarity of the data structure used to represent sorted sets). They are ordered according to the following rule:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:819
# 7f2ea38a598d429492889fc798808738
msgid "If A and B are two elements with a different score, then A > B if A.score is > B.score."
msgstr ""

#: ../../source/topics/data-types-intro.rst:821
# 2a53230fc60c4b2290eacf5181768d9a
msgid "If A and B have exactly the same score, than A > B if the A string is lexicographically greater than the B string. A and B strings can't be equal since sorted sets only have unique elements."
msgstr ""

#: ../../source/topics/data-types-intro.rst:825
# 79ff75f80c9346fd80272f912f55de13
msgid "Let's start with a simple example, adding a few selected hackers names as sorted set elements, with their year of birth as \"score\"."
msgstr ""

#: ../../source/topics/data-types-intro.rst:849
# 675c2b2c7e6a40abb51b535ffd0ad31c
msgid "As you can see ``ZADD`` is similar to ``SADD``, but takes one argument more (placed before the element to add itself), which is the score. ``ZADD`` is also variadic, so you are free to specify multiple score-value pairs, even if this is not used in the example above."
msgstr ""

#: ../../source/topics/data-types-intro.rst:854
# be2e3872ff2c417086b34b4108f08df4
msgid "With sorted sets it is trivial to return a list of hackers sorted by their birth year because actually *they are already sorted*."
msgstr ""

#: ../../source/topics/data-types-intro.rst:857
# 416c64500503452597805502c5e12254
msgid "Implementation note: Sorted sets are implemented via a dual-ported data structure containing both a skip list and a hash table, so every time we add an element Redis performs an O(log(N)) operation. That's good, but when we ask for sorted elements Redis does not have to do any work at all, it's already all sorted:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:876
# 1b74465a41474316b63f633e44a5ca2d
msgid "Note: 0 and -1 means from element index 0 to the last element (-1 works like in the case of the ``LRANGE`` command)."
msgstr ""

#: ../../source/topics/data-types-intro.rst:879
# e24bf9905ccf4683b709b48ec9c04e02
msgid "What if I want to order them the opposite way, youngest to oldest? Use `ZREVRANGE </commands/zrevrange>`__ instead of `ZRANGE </commands/zrange>`__:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:896
# cfdc5f43c0814d13bd8f824a921c76a5
msgid "It is possible to return scores as well, using the ``WITHSCORES`` argument:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:922
# 7a7d818f13db4b029c68e5a6ce4de72e
msgid "Operating on ranges"
msgstr ""

#: ../../source/topics/data-types-intro.rst:924
# cfe50a4615f64a2b8fbd22ebf3ae3586
msgid "Sorted sets are more powerful than this. They can operate on ranges. Let's get all the individuals that were born up to the 1950 inclusive. We use the ``ZRANGEBYSCORE`` command to do it:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:937
# 738a8ec1bb7d49bc82a7d1dd07711fe6
msgid "We asked Redis to return all the elements with a score between negative infinity and 1950 (both extremes are included)."
msgstr ""

#: ../../source/topics/data-types-intro.rst:940
# e8584609505c46b18ecae1e462966de4
msgid "It's also possible to remove ranges of elements. Let's remove all the hackers born between 1940 and 1960 from the sorted set:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:948
# 2803bce9ec9e477a8d76c3030c1183e5
msgid "``ZREMRANGEBYSCORE`` is perhaps not the best command name, but it can be very useful, and returns the number of removed elements."
msgstr ""

#: ../../source/topics/data-types-intro.rst:951
# 36e478f0525c406184ac09137307b693
msgid "Another extremely useful operation defined for sorted set elements is the get-rank operation. It is basically possible to ask what is the position of an element in the set of the order elements."
msgstr ""

#: ../../source/topics/data-types-intro.rst:960
# 4585ad8f27554313a9756fed22fab197
msgid "The ``ZREVRANK`` command is also available in order to get the rank considering the elements sorted a descending way."
msgstr ""

#: ../../source/topics/data-types-intro.rst:964
# 3baeae39031c4596bee42070a7770f5d
msgid "Lexicographical scores"
msgstr ""

#: ../../source/topics/data-types-intro.rst:966
# ab610723b4d0413b9b94a5c783de951b
msgid "With recent versions of Redis 2.8, a new feature was introduced that allows, assuming elements in a sorted set are all inserted with the same identical score, to get ranges lexicographically (elements are compared with the C ``memcmp`` function, so it is guaranteed that there is no collation, and every Redis instance will reply with the same output)."
msgstr ""

#: ../../source/topics/data-types-intro.rst:972
# c203f2c5c10f4fcf8f44826306f6fd5d
msgid "The main commands to operate with lexicographical ranges are ``ZRANGEBYLEX``, ``ZREVRANGEBYLEX``, ``ZREMRANGEBYLEX`` and ``ZLEXCOUNT``."
msgstr ""

#: ../../source/topics/data-types-intro.rst:976
# a925269fe8a74215a1cad8075f8b4797
msgid "For example, let's add again our list of famous hackers. But this time, use a score of zero for all the elements:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:985
# cf21832cfb3b40758dfb1e03b113bd1c
msgid "Because of the sorted sets ordering rules, they are already sorted lexicographically:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:1001
# de9b38ea1c2047fa8fd68cee33f49de4
msgid "Using ``ZRANGEBYLEX`` we can ask for lexicographical ranges:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:1010
# cda1f80ff8cf4366bce8d0bc2a1767b3
msgid "Ranges can be inclusive or exclusive (depending on the first character), also string infinite and minus infinite are specified respectively with the ``+`` and ``-`` strings. See the documentation for more information."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1014
# 9a3d9f1e3dc343ad946a41cc6539cc17
msgid "This feature is important because allows to use sorted sets as a generic index. For example, if you want to index elements by a 128-bit unsigned integer argument, all you need to do is to add elements into a sorted set with the same score (for example 0) but with an 8 bytes prefix consisting of **the 128 bit number in big endian**. Since numbers in big endian, when ordered lexicographically (in raw bytes order) are actually ordered numerically as well, you can ask for ranges in the 128 bit space, and get the elements value discarding the prefix."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1023
# 3d2c78444c7f46bf96be3ab75afa396c
msgid "If you want to see the feature in the context of a more serious demo, check the `Redis autocomplete demo <http://autocomplete.redis.io>`__."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1027
# ecdddcde5ad6499c91e50591856876ba
msgid "Updating the score: leader boards"
msgstr ""

#: ../../source/topics/data-types-intro.rst:1029
# 42af91b7dedc413bbc9c4ee8c8da1ba3
msgid "Just a final note about sorted sets before switching to the next topic. Sorted sets scores can be updated at any time. Just calling again ZADD against an element already included in the sorted set will update its score (and position) with O(log(N)) time complexity, so sorted sets are suitable when there are tons of updates."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1035
# a8cf9e0d066c4e14bab80107af8d841c
msgid "Because of this characteristic a common use case is leader boards. The typical application is a Facebook game where you combine the ability to take users sorted by their high score, plus the get-rank operation, in order to show the top-N users, and the user rank in the leader board (you are the #4932 best score here)."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1042
# 2a070ee755a84d529619e9ec0a219736
msgid "HyperLogLogs"
msgstr ""

#: ../../source/topics/data-types-intro.rst:1044
# 3c58a041dc0644359a7ce1b6c3064aab
msgid "An HyperLogLog is a probabilistic data structure used in order to count unique things (technically this is referred to estimating the cardinality of a set). Usually counting unique items require to use an amount of memory proportional to the number of items you want to count, because you need to remember the elements you already seen in the past, in order to avoid to count them multiple times. However there is a set of algorithms that trade memory for precision: you end with an estimated measure, with a standard error, in the case of the Redis implementation, which is less than 1%, but the magic of this algorithms is that you no longer need to use an amount of memory proportional to the number of things counted, you just need to use a constant amount of memory! 12k bytes in the worst case, or a lot less if you HyperLogLog (We'll just call them HLL from now) has seen very few elements."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1058
# 9f9dddd369694a1595616388f460b5e9
msgid "HLLs in Redis, while technically a different data structure, is encoded as a Redis string, so you can call ``GET`` to serialize an HLL, and ``SET`` to un-serialize it back to the server."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1062
# 516a961d49a943b4bfb7e1aae6202cae
msgid "Conceptually the HLL API is like using Sets to do the same task. You would ``SADD`` every observed element into a set, and would use ``SCARD`` to check the number of elements inside the set, which are unique since ``SCARD`` will not re-add an already added element."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1067
# df0754c8ae2645759f9ea0b0d8eb4b06
msgid "While you don't really *add items* into an HLL, because the data structure only contains a state that does not include actual elements, the API is the same:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:1071
# d3c34fe2bc694a53855c3229f335ab9b
msgid "Every time you see a new element, you add it to the count with ``PFADD``."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1073
# cd02f0cbf8334d4d99f15d773f276f47
msgid "Every time you want to retrieve the current approximation of the unique elements *added* with ``PFADD`` so far, you use the ``PFCOUNT``."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1077
# 550ea6a887f34b3c95c65d11e9dd5e4f
msgid "pfadd hll a b c d (integer) 1 pfcount hll (integer) 4"
msgstr ""

#: ../../source/topics/data-types-intro.rst:1079
# 046be28c03364155b8cbe56ff7c5b3bf
msgid "An example of use case for this data structure is counting unique queries performed by users in a search form every day."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1082
# e67a7a3bb8dd40afa138d0d22e5f97cb
msgid "Redis is also able to perform the union of HLLs, please check the `full documentation </commands#hyperloglog>`__ for more information."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1086
# b117e88d701e431c82bcd59ea53ce1c6
msgid "Other notable features"
msgstr ""

#: ../../source/topics/data-types-intro.rst:1088
# d78e22756cbf4364af3745d77ccedaba
msgid "There are other important things in the Redis API that can't be explored in the context of this document, but are worth your attention:"
msgstr ""

#: ../../source/topics/data-types-intro.rst:1091
# 7bd304e7c23242fea4eb829dd946b752
msgid "It is possible to `iterate the key space or a large collection incrementally </commands/scan>`__."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1093
# e4c6840e1e94473085fa39bdb3ce4f6f
msgid "It is possible to run `Lua scripts server side </commands/eval>`__ to win latency and bandwidth."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1095
# 054a61f6df26403bac8ded6bfc97bbc2
msgid "Redis is also a `Pub-Sub server </topics/pubsub>`__."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1098
# 13af49ea54df41b098eb4843ca082262
msgid "Learn more"
msgstr ""

#: ../../source/topics/data-types-intro.rst:1100
# 9efbc1ce51b541a9a0416bcd7a036b8a
msgid "This tutorial is in no way complete and has covered just the basics of the API. Read the `command reference </commands>`__ to discover a lot more."
msgstr ""

#: ../../source/topics/data-types-intro.rst:1104
# 3ba311da78ce45db95ae80d33824fa1b
msgid "Thanks for reading, and have a good hacking with Redis!"
msgstr ""

