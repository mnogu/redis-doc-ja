# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014, moco_beta
# This file is distributed under the same license as the Redis Documentation (Japanese) package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Redis Documentation (Japanese) 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-07-31 23:30+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/topics/persistence.rst:1
# b5fde0fb71864d00bd93a8f94565c767
msgid "This page provides a technical description of Redis persistence, it is a suggested read for all the Redis users. For a wider overview of Redis persistence and the durability guarantees it provides you may want to also read `Redis persistence demystified <http://antirez.com/post/redis-persistence-demystified.html>`__."
msgstr "このページでは Redis の永続化について、技術的な説明を提供します。すべての Redis ユーザーはこの内容に目を通しておくことを推奨します。Redis の永続化と障害耐性の保証について、より広範に概観するため `Redis persistence demystified <http://antirez.com/post/redis-persistence-demystified.html>`_ も参照すると良いでしょう。"

#: ../../source/topics/persistence.rst:8
# 20712e3648144bbe9082d88b5a455d6d
msgid "Redis Persistence"
msgstr "Redis の永続化"

#: ../../source/topics/persistence.rst:10
# 289d83f5e0fc45b8a7d2f848c44f1f38
msgid "Redis provides a different range of persistence options:"
msgstr "Redis は、守備範囲の異なる永続化オプションを提供します:"

#: ../../source/topics/persistence.rst:12
# 7a094414330444d494c2552256b4681c
msgid "The RDB persistence performs point-in-time snapshots of your dataset at specified intervals."
msgstr "RDB 永続化は、ある時点のデータセットのスナップショットを、特定の間隔ごとに作成します。"

#: ../../source/topics/persistence.rst:14
# 5a15a315611343a0bfcc6e64fdc0a025
msgid "the AOF persistence logs every write operation received by the server, that will be played again at server startup, reconstructing the original dataset. Commands are logged using the same format as the Redis protocol itself, in an append-only fashion. Redis is able to rewrite the log on background when it gets too big."
msgstr "AOF 永続化では、サーバーが受け付けたすべての書き込みコマンドを記録します。サーバーは起動時にログをリプレイし、元のデータを再構成します。コマンドは Redis プロトコルと同じフォーマットを使い、追記方式で記録されます。ログが大きくなりすぎたら、Redis はバックグラウンドでそれをリライトします。"

#: ../../source/topics/persistence.rst:19
# 5ba74d4a8dba48eba9ea4d0641f3614e
msgid "If you wish, you can disable persistence at all, if you want your data to just exist as long as the server is running."
msgstr "サーバーが起動している間のみデータが存在するようにしたい場合、望むなら永続化を完全に無効とすることもできます。"

#: ../../source/topics/persistence.rst:21
# 1d514c5a2f9640e282b56123135fe07e
msgid "It is possible to combine both AOF and RDB in the same instance. Notice that, in this case, when Redis restarts the AOF file will be used to reconstruct the original dataset since it is guaranteed to be the most complete."
msgstr "同じインスタンスで、AOF と RDB の両方を組み合わせることも可能です。その場合、Redis の再起動時、元のデータを再構成するために AOF ファイルが使われることに留意してください。なぜなら、そちらのほうがより完全であると保証されるためです。"

#: ../../source/topics/persistence.rst:26
# 8b892954d72347638226649a61f080df
msgid "The most important thing to understand is the different trade-offs between the RDB and AOF persistence. Let's start with RDB:"
msgstr "もっとも重要なことは、RDB と AOF の、異なるトレードオフについて理解することです。RDB から始めましょう:"

#: ../../source/topics/persistence.rst:30
# 4c974e60a07a4475a3d668f2ef7f7bba
msgid "RDB advantages"
msgstr "RDB の利点"

#: ../../source/topics/persistence.rst:32
# a3562edda3174e7da6458f005cbe096c
msgid "RDB is a very compact single-file point-in-time representation of your Redis data. RDB files are perfect for backups. For instance you may want to archive your RDB files every hour for the latest 24 hours, and to save an RDB snapshot every day for 30 days. This allows you to easily restore different versions of the data set in case of disasters."
msgstr "RDB は、ある時点の Redis データを表現した、非常にコンパクトな 1 つのファイルです。RDB ファイルはバックアップに最適です。たとえば、直近 24 時間については 1 時間ごとに RDB ファイルをアーカイブし、直近 30 日については日ごとに RDB スナップショットを保存する、などです。これにより、災害時において、データセットの異なるバージョンを簡単にリストア可能です。"

#: ../../source/topics/persistence.rst:38
# 8521e681beb04e04b26bd7c465fbc553
msgid "RDB is very good for disaster recovery, being a single compact file can be transfered to far data centers, or on Amazon S3 (possibly encrypted)."
msgstr "RDB は 1 つのコンパクトなファイルであり、遠隔のデータセンター、ないし Amazon S3 (おそらく暗号化されるでしょう) へと転送できるため、災害復旧にとても適しています。"

#: ../../source/topics/persistence.rst:41
# 561f2bc5e3ab4640b17031d3a435340f
msgid "RDB maximizes Redis performances since the only work the Redis parent process needs to do in order to persist is forking a child that will do all the rest. The parent instance will never perform disk I/O or alike."
msgstr "RDB は Redis の性能を最大化します。なぜなら、永続化の際に親プロセスが行う必要があるのは子プロセスを fork するだけであり、残りの仕事はすべて子プロセスが受け持つためです。親のインスタンスがディスク I/O その他を実行することはありません。"

#: ../../source/topics/persistence.rst:45
# 97ca8facf3ff454fb92e1745803e2fa4
msgid "RDB allows faster restarts with big datasets compared to AOF."
msgstr "RDB は、大きなデータセットの場合に、AOF よりも高速な起動を可能にします。"

#: ../../source/topics/persistence.rst:48
# 653990da2bd64ec2b28692c23458b703
msgid "RDB disadvantages"
msgstr "RDB の欠点"

#: ../../source/topics/persistence.rst:50
# fb703659a55a4a6c9e1d8d9a6c598509
msgid "RDB is NOT good if you need to minimize the chance of data loss in case Redis stops working (for example after a power outage). You can configure different *save points* where an RDB is produced (for instance after at least five minutes and 100 writes against the data set, but you can have multiple save points). However you'll usually create an RDB snapshot every five minutes or more, so in case of Redis stopping working without a correct shutdown for any reason you should be prepared to lose the latest minutes of data."
msgstr "Redis が停止した際(電源遮断の後など)、データロスの機会を最小化したい場合には RDB は適しません。RDB が生成される、異なる *セーブポイント* を設定することができます(たとえば、少なくとも 5 分間に 100 の書き込みがデータセットに発生した後、など。ただしセーブポイントは複数指定できます)。しかし、通常においては RDB スナップショットは 5 分ごと、もしくはもっと長い間隔で作成されるため、何らかの理由で Redis が正しくシャットダウンされずに停止した場合、最後の数分のデータを失うことを予期しておかないといけません。"

#: ../../source/topics/persistence.rst:58
# 86ab8ec612774986a38971c34a20f610
msgid "RDB needs to fork() often in order to persist on disk using a child process. Fork() can be time consuming if the dataset is big, and may result in Redis to stop serving clients for some millisecond or even for one second if the dataset is very big and the CPU performance not great. AOF also needs to fork() but you can tune how often you want to rewrite your logs without any trade-off on durability."
msgstr "RDB は 子プロセスを使ってディスクに永続化を行うため、頻繁に fork() する必要があります。Fork() はデータセットが大きいと時間がかかるため、もしデータセットが非常に大きく、CPU性能があまり良くないと、数ミリ秒、悪くて 1 秒程度にわたって Redis はクライアントに応答するのを中断します。AOF も fork() を必要としますが、耐障害性を損うことなく、どのくらいの頻度でリライトを行うかを調整することができます。"

#: ../../source/topics/persistence.rst:66
# a355fc8a96f84766b0dc8acbb9bb2a59
msgid "AOF advantages"
msgstr "AOF の利点"

#: ../../source/topics/persistence.rst:68
# 516ad7a83d6b4fdfba2f6ea705ecfd58
msgid "Using AOF Redis is much more durable: you can have different fsync policies: no fsync at all, fsync every second, fsync at every query. With the default policy of fsync every second write performances are still great (fsync is performed using a background thread and the main thread will try hard to perform writes when no fsync is in progress.) but you can only lose one second worth of writes."
msgstr "AOF を使うと、Redis はより障害に強くなります。異なる fsync ポリシーを選択できます: fsync を全く行わない、毎秒 fsync を実行する、すべてのクエリごとに fsync を実行する。デフォルトポリシーの「毎秒 fsync を実行する」を使うことで、書き込みをロスする可能性のある時間を 1 秒以内に抑えながら、高い書き込み性能を維持できます(fsync はバックグラウンドプロセスを使って実行され、fsync が実行中でない間、メインスレッドは書き込みを行うように最大限努めます)。"

#: ../../source/topics/persistence.rst:74
# 040b390c17254731a7c769ce8954c971
msgid "The AOF log is an append only log, so there are no seeks, nor corruption problems if there is a power outage. Even if the log ends with an half-written command for some reason (disk full or other reasons) the redis-check-aof tool is able to fix it easily."
msgstr "AOF ログは追記専用のログであるため、シークがなく、電源遮断による破損の問題も発生しません。何らかの理由によりログが書き込みコマンドの途中で終わっていた場合でも(ディスクフルその他の原因により)、redis-check-aof ツールで簡易に修復可能です。"

#: ../../source/topics/persistence.rst:78
# 1c221813771d4d5cbbea438335fab9e2
msgid "Redis is able to automatically rewrite the AOF in background when it gets too big. The rewrite is completely safe as while Redis continues appending to the old file, a completely new one is produced with the minimal set of operations needed to create the current data set, and once this second file is ready Redis switches the two and starts appending to the new one."
msgstr "AOF が肥大化してくると、Redis は自動的にバックグラウンドでリライトを行います。Redis が継続して古いファイルに追記している間も、リライトは完全に安全です。現在のデータセットを作成するのに必要な最小限の操作を記録した、まったく新しいファイルが作成されます。この、2 つめのファイルの準備が整ったら Redis は 2 つのファイルを入れ替え、新しいほうに追記を始めます。"

#: ../../source/topics/persistence.rst:84
# 5bb95f444cfe49209b739eb7bdbba28f
msgid "AOF contains a log of all the operations one after the other in an easy to understand and parse format. You can even easily export an AOF file. For instance even if you flushed everything for an error using a FLUSHALL command, if no rewrite of the log was performed in the meantime you can still save your data set just stopping the server, removing the latest command, and restarting Redis again."
msgstr "AOF はすべての操作を順々に、理解しやすくパースしやすいフォーマットで保持しています。AOF ファイルは簡単にエクスポートできます。たとえば、手違いで FLUSHALL コマンドを発行してすべてを消去してしまった場合でも、その間でリライトが発生していなければ、サーバーを停止して最後のコマンドを削除し、Redis を再起動することでデータセットを救うことができます。"

#: ../../source/topics/persistence.rst:92
# f773fe1b8b1f41bbb937155c525e716a
msgid "AOF disadvantages"
msgstr "AOF の欠点"

#: ../../source/topics/persistence.rst:94
# 311d57704dbd491db9f8c9551d348f25
msgid "AOF files are usually bigger than the equivalent RDB files for the same dataset."
msgstr "AOF ファイルは通常、同じデータセットを表す等価な RDB ファイルよりも大きくなります。"

#: ../../source/topics/persistence.rst:96
# 40c473d181a949c0bc9b762e48ef1743
msgid "AOF can be slower than RDB depending on the exact fsync policy. In general with fsync set to *every second* performances are still very high, and with fsync disabled it should be exactly as fast as RDB even under high load. Still RDB is able to provide more guarantees about the maximum latency even in the case of an huge write load."
msgstr "AOF は、正確な fsync ポリシーにより RDB よりも遅くなることがあります。一般的には fsync を *毎秒* に設定しておくことで高い性能を維持でき、また、fsync を無効にすると、非常に高負荷な状況下でも RDB とまったく同等の速度になります。しかしながら、RDB は書き込み負荷が非常に高い場合においても、最大レイテンシを保証することが可能です。"

#: ../../source/topics/persistence.rst:101
# 92bbc0f3563d46a887a665dc28b68503
msgid "In the past we experienced rare bugs in specific commands (for instance there was one involving blocking commands like BRPOPLPUSH) causing the AOF produced to not reproduce exactly the same dataset on reloading. This bugs are rare and we have tests in the test suite creating random complex datasets automatically and reloading them to check everything is ok, but this kind of bugs are almost impossible with RDB persistence. To make this point more clear: the Redis AOF works incrementally updating an existing state, like MySQL or MongoDB does, while the RDB snapshotting creates everything from scratch again and again, that is conceptually more robust. However -"
msgstr "過去に、特定のコマンド(たとえば、BRPOPLPUSH のようなブロッキングコマンド)において、データリロード時に、AOF が正確なデータセットを再生成しない、という稀なバグがありました。このバグは稀なもので、また、私たちはランダムで複雑なデータセットを自動生成してリロードし、すべてが問題ないかをチェックするテストスイートを用意しています。この点をよりクリアにします: Redis AOF は、MySQL や MongoDB のように、現在の状態をインクリメンタルにアップデートする働きをします。一方で、RDB スナップショットは都度都度、スクラッチからすべてを生成するため、理論上より頑健です。しかし、"

#: ../../source/topics/persistence.rst:112
# d31ce1cf93014edaaea8849dc160a34f
msgid "It should be noted that every time the AOF is rewritten by Redis it is recreated from scratch starting from the actual data contained in the data set, making resistance to bugs stronger compared to an always appending AOF file (or one rewritten reading the old AOF instead of reading the data in memory)."
msgstr "Redis により AOF がリライトされる都度、それはデータセット中の実際のデータから、スクラッチで再生成されます。これにより、常にひとつの AOF に追記し続ける(または、メモリ上のデータではなく、古い AOF を読んでリライトする)のと比較すると、バグに強くなります。この点は強調しておくべきでしょう。"

#: ../../source/topics/persistence.rst:117
# 4794e10eebfa4555a14b2a002057b060
msgid "We never had a single report from users about an AOF corruption that was detected in the real world."
msgstr "私たちは、実環境において、AOF が破損したという報告をユーザーから受けたことは 1 度もありません。"

#: ../../source/topics/persistence.rst:121
# c4a59397b117461fa9acc53fd7914687
msgid "Ok, so what should I use?"
msgstr "よくわかった、 それでは、私はどちらを使ったらいいのか？"

#: ../../source/topics/persistence.rst:123
# 50e64bfaf94b4c82bf5408cb1036e5c6
msgid "The general indication is that you should use both persistence methods if you want a degree of data safety comparable to what PostgreSQL can provide you."
msgstr "一般的に言って、PostgreSQL が提供するのと同等レベルのデータ安全性を確保したいときは、両方の永続化メソッドを併用することを推奨します。"

#: ../../source/topics/persistence.rst:127
# 4de53f7083084a51a268e535e880bafb
msgid "If you care a lot about your data, but still can live with a few minutes of data lose in case of disasters, you can simply use RDB alone."
msgstr "扱うデータが多く、災害時において数分間のデータロスを許容できるなら、単に RDB のみを使うと良いでしょう。"

#: ../../source/topics/persistence.rst:130
# d1abba3fbef946df80e18851beba9f26
msgid "There are many users using AOF alone, but we discourage it since to have an RDB snapshot from time to time is a great idea for doing database backups, for faster restarts, and in the event of bugs in the AOF engine."
msgstr "多くのユーザーが AOF のみを使っていますが、私たちはこのやり方を推奨しません。なぜなら、その時々の RDB スナップショットはデータベースのバックアップに最適で、再起動が高速にできるためです。また、AOF には万一のバグがありえます。"

#: ../../source/topics/persistence.rst:135
# 749baffcd1784c45bd9493f3ba2027c8
msgid "Note: for all these reasons we'll likely end up unifying AOF and RDB into a single persistence model in the future (long term plan)."
msgstr "追記: これらの理由により、私たちは将来的に(長期プランとして)、AOF と RDB をひとつの永続化モデルに統合することを検討しています。"

#: ../../source/topics/persistence.rst:138
# f41f534f917648239626c3eb5d6b4763
msgid "The following sections will illustrate a few more details about the two persistence models."
msgstr "以下のセクションでは、2 つの永続化モデルについてより詳細を記述します。"

#: ../../source/topics/persistence.rst:141
# 7117b028e3514adcb97a53ca7d104942
msgid "Snapshotting ---"
msgstr "スナップショット"

#: ../../source/topics/persistence.rst:143
# 4f00b928ae394d988417608ccd1ece9e
msgid "By default Redis saves snapshots of the dataset on disk, in a binary file called ``dump.rdb``. You can configure Redis to have it save the dataset every N seconds if there are at least M changes in the dataset, or you can manually call the ``SAVE`` or ``BGSAVE`` commands."
msgstr "デフォルトで、Redis は ``dump.rdb`` と呼ばれるバイナリファイル内に、データセットのスナップショットを保存します。データセットに対して、毎 N 秒ごとに少なくとも M 回の変更があったら保存を行うよう、 Redis の設定が可能です。または、手動で `SAVE <http://redis.io/commands/save>`_ および `BASAVE <http://redis.io/commands/bgsave>`_ コマンドを発行できます。"

#: ../../source/topics/persistence.rst:148
# bf3dcc3a345849e2b60231b893467773
msgid "For example, this configuration will make Redis automatically dump the dataset to disk every 60 seconds if at least 1000 keys changed:"
msgstr "たとえば、次の設定では、60 秒毎に少なくとも 1000 個のキーの変更があったら Redis はデータセットをディスクに保存します。"

#: ../../source/topics/persistence.rst:155
# 07494d44633a4c3b899f7fc1fbca0f54
msgid "This strategy is known as *snapshotting*."
msgstr "この戦略は *snapshotting* として知られています。"

#: ../../source/topics/persistence.rst:158
#: ../../source/topics/persistence.rst:253
# c8aa19f9cf1b4b46b57c9ef3e6b11c46
# edeb1e94d4b24726be2a9147530aedf0
msgid "How it works"
msgstr "これはどのように動作するか"

#: ../../source/topics/persistence.rst:160
# d72508a128c245289f907c88256e11f0
msgid "Whenever Redis needs to dump the dataset to disk, this is what happens:"
msgstr "Redis がデータセットをディスクにダンプする必要があるときはいつでも、以下の処理が行われます:"

#: ../../source/topics/persistence.rst:162
# f328a0cbff49406e95ebbcdc04ab9686
msgid "Redis `forks <http://linux.die.net/man/2/fork>`__. We now have a child and a parent process."
msgstr "Redis は `fork <http://linux.die.net/man/2/fork>`_ を実行します。子プロセスと、親プロセスが動いている状態になります。"

#: ../../source/topics/persistence.rst:165
# c6fc3279687f417d889c887daa1b5e8f
msgid "The child starts to write the dataset to a temporary RDB file."
msgstr "子プロセスはデータセットを一時 RDB ファイルに書き出し始めます。"

#: ../../source/topics/persistence.rst:167
# 2f691d8ef71f424e96ae1f518ff8ebd2
msgid "When the child is done writing the new RDB file, it replaces the old one."
msgstr "子プロセスは新しい RDB ファイルの書き出しを終えると、古いものと置き換えます。"

#: ../../source/topics/persistence.rst:170
# 1b887d72b82c4bccb144d4d2682bf5ab
msgid "This method allows Redis to benefit from copy-on-write semantics."
msgstr "この方法により Redis は、copy-on-write セマンティクスの恩恵が受けられます。"

#: ../../source/topics/persistence.rst:172
# d12df0cd94af4be8b01d088dd93dce99
msgid "Append-only file ---"
msgstr "追記専用ファイル"

#: ../../source/topics/persistence.rst:174
# c3c46a386eed46fabbf57ee6de2fa2c9
msgid "Snapshotting is not very durable. If your computer running Redis stops, your power line fails, or you accidentally ``kill -9`` your instance, the latest data written on Redis will get lost. While this may not be a big deal for some applications, there are use cases for full durability, and in these cases Redis was not a viable option."
msgstr "スナップショットは障害に強くありません。Redis が動いているコンピューターが停止したら、電源で問題が発生したら、または事故でインスタンスを ``kill -9`` してしまったら、Redis に書かれた直近の変更は失われます。これはある種のアプリケーションにとっては大きな問題にならない一方、完全な耐障害性が必要となるユースケースもあります。こうしたケースにおいては、Redis は実行可能な選択肢ではありません。"

#: ../../source/topics/persistence.rst:180
# ab1a13a97fe54fc4a54ac65c4692278c
msgid "The *append-only file* is an alternative, fully-durable strategy for Redis. It became available in version 1.1."
msgstr "*追記専用ファイル* は、Redis で完全な耐障害性を実現するための、代替の戦略です。バージョン 1.1 から利用できるようになりました。"

#: ../../source/topics/persistence.rst:183
# b06ca003b35b4ec2a582b055ef439172
msgid "You can turn on the AOF in your configuration file:"
msgstr "設定ファイルで AOF を有効にできます:"

#: ../../source/topics/persistence.rst:189
# 44cc9528ace04df882edd0c8c9347115
msgid "From now on, every time Redis receives a command that changes the dataset (e.g. ``SET``) it will append it to the AOF. When you restart Redis it will re-play the AOF to rebuild the state."
msgstr "以降、Redis はデータセットを変更するコマンド(e.g. `SET <http://redis.io/commands/set>`_)を受け付ける都度、AOF に追記します。Redis を再起動したときは、AOF ファイルをリプレイして状態を再構成します。"

#: ../../source/topics/persistence.rst:194
# bb9d9ed7e6e240858c9f822d57874938
msgid "Log rewriting"
msgstr "ログのリライト"

#: ../../source/topics/persistence.rst:196
# 7d2c9604879e4e58b2b339a1dee9d020
msgid "As you can guess, the AOF gets bigger and bigger as write operations are performed. For example, if you are incrementing a counter 100 times, you'll end up with a single key in your dataset containing the final value, but 100 entries in your AOF. 99 of those entries are not needed to rebuild the current state."
msgstr "すぐに推測できるように、書き込み操作が実行されるに応じて、AOF はどんどん大きくなります。たとえば、あるカウンターを 100 回インクリメントした場合、最終的にデータセット内には最後の値しか含まれないですが、AOF には 100 個のエントリが含まれることになります。そのうち 99 エントリは、現在の状態を再構成するためには不要なものです。"

#: ../../source/topics/persistence.rst:202
# dfd101ab41014664903008eb8f5e0858
msgid "So Redis supports an interesting feature: it is able to rebuild the AOF in the background without interrupting service to clients. Whenever you issue a ``BGREWRITEAOF`` Redis will write the shortest sequence of commands needed to rebuild the current dataset in memory. If you're using the AOF with Redis 2.2 you'll need to run ``BGREWRITEAOF`` from time to time. Redis 2.4 is able to trigger log rewriting automatically (see the 2.4 example configuration file for more information)."
msgstr "そのため、Redis は興味深い機能をサポートしています: クライアントへのサービスを中断することなく、バックグラウンドで AOF の再構築を行います。 `BGREWRITEAOF <http://redis.io/commands/bgrewriteaof>`_ コマンドを発行すると、Redis は、メモリ上の現在のデータセットを再構成するのに必要な、最小限のコマンドシーケンスを書き出します。もし Redis 2.2 で AOF を使っていたら、時々 ``BGREWRITEAOF`` コマンドを自分で実行する必要があります。Redis 2.4 以降、ログの自動リライトのトリガーを設定できるようになりました(詳しくは 2.4 [訳注:以降] の設定ファイルを参照してください)。"

#: ../../source/topics/persistence.rst:211
# 2c58be946a2843c09d72be932b2012dd
msgid "How durable is the append only file?"
msgstr "追記専用ファイルは、どの程度の障害耐性がありますか？"

#: ../../source/topics/persistence.rst:213
# 6dda8587e0f64731b9b964d1898d78d2
msgid "You can configure how many times Redis will ```fsync`` <http://linux.die.net/man/2/fsync>`__ data on disk. There are three options:"
msgstr "Redis が、データをディスクに `fsync <http://linux.die.net/man/2/fsync>`_ する頻度を設定できます。3 つのオプションがあります: "

#: ../../source/topics/persistence.rst:217
# ce1581a537944e5c828510526a3946a5
msgid "``fsync`` every time a new command is appended to the AOF. Very very slow, very safe."
msgstr "新しいコマンドが AOF に追加される都度、 ``fsync`` を実行します。とても遅く、とても安全です。"

#: ../../source/topics/persistence.rst:220
# e73f48c2e306494080c02e2fe7e00972
msgid "``fsync`` every second. Fast enough (in 2.4 likely to be as fast as snapshotting), and you can lose 1 second of data if there is a disaster."
msgstr "毎秒 ``fsync`` を実行します。十分に高速(バージョン 2.4 ではスナップショットと同程度に高速)ですが、災害(事故)の際は 1 秒間のデータを失う可能性があります。"

#: ../../source/topics/persistence.rst:224
# c3fbae0f5c6f47bbb5593a6007f4db48
msgid "Never ``fsync``, just put your data in the hands of the Operating System. The faster and less safe method."
msgstr "``fsync`` を実行せず、オペレーティングシステムに任せる。もっとも高速で、もっとも安全性の低い方法です。"

#: ../../source/topics/persistence.rst:227
# ed0d5dc748dc410fb12d8287eb1f0fc7
msgid "The suggested (and default) policy is to ``fsync`` every second. It is both very fast and pretty safe. The ``always`` policy is very slow in practice (although it was improved in Redis 2.0) – there is no way to make ``fsync`` faster than it is."
msgstr "推奨(かつ、デフォルト)は毎秒 ``fsync`` を実行するポリシーです。これは非常に高速で、かつ十分に安全です。 ``always`` ポリシーは現実的に大変遅いです(Redis 2.0 で改善はされていますが)。 ``fsync`` それ自体を速くする方法はありません。"

#: ../../source/topics/persistence.rst:233
# 6c91fc4ae8d740418a423fbb3a225944
msgid "What should I do if my AOF gets corrupted?"
msgstr "もし AOF が破損したらどうしたらいいか？"

#: ../../source/topics/persistence.rst:235
# 14e50b46640b41aabd1ebb9b9fbb9136
msgid "It is possible that the server crashes while writing the AOF file (this still should never lead to inconsistencies), corrupting the file in a way that is no longer loadable by Redis. When this happens you can fix this problem using the following procedure:"
msgstr "AOF ファイルを書き込み中にサーバーがクラッシュし(ただし、一貫性が保たれなくなることはありません)、ファイルが破損して Redis がロードできなくなってしまう可能性があります。こうした場合は、以下の手順で修正を実施してください:"

#: ../../source/topics/persistence.rst:240
# 1512929bc30e4f7cacd658e8322062d8
msgid "Make a backup copy of your AOF file."
msgstr "AOF ファイルのバックアップコピーを取得する。"

#: ../../source/topics/persistence.rst:242
# 3acc503038874c4b9f24b15bc054706d
msgid "Fix the original file using the ``redis-check-aof`` tool that ships with Redis:"
msgstr "元のファイルに、Redis に同梱されている ``redis-check-aof`` ツールを適用して修正する:"

#: ../../source/topics/persistence.rst:245
# 9a7bd1bcb3ba4d07acd47ea6b2513803
msgid "$ redis-check-aof --fix"
msgstr ""

#: ../../source/topics/persistence.rst:247
# ee774b4caf03444cb190fbaabc3ef81e
msgid "Optionally use ``diff -u`` to check what is the difference between two files."
msgstr "必要に応じて、 ``diff -u`` で 2 つのファイルの差分をチェックする。"

#: ../../source/topics/persistence.rst:250
# f46ce44472fc4c5e93ea3ce9eee7f1b3
msgid "Restart the server with the fixed file."
msgstr "修正したファイルを使ってサーバーを再起動する。"

#: ../../source/topics/persistence.rst:255
# 14748f41580d4f9c8567d155fa0fa048
msgid "Log rewriting uses the same copy-on-write trick already in use for snapshotting. This is how it works:"
msgstr "ログリライトは、スナップショットで使っているのと同じ copy-on-write トリックを使っています。これは以下のように動作します:"

#: ../../source/topics/persistence.rst:258
# 157bbff460a145978366cdc4237af65c
msgid "Redis `forks <http://linux.die.net/man/2/fork>`__, so now we have a child and a parent process."
msgstr "Redis は `fork <http://linux.die.net/man/2/fork>`_ を実行し、子プロセスと親プロセスが動いている状態になります。"

#: ../../source/topics/persistence.rst:261
# 19e6eb54baf04d7aa15e50687465c231
msgid "The child starts writing the new AOF in a temporary file."
msgstr "子プロセスは、新しい AOF を一時ファイルへ書き出し始めます。"

#: ../../source/topics/persistence.rst:263
# 5d37b4a70119491aaad1eb3ba6698dba
msgid "The parent accumulates all the new changes in an in-memory buffer (but at the same time it writes the new changes in the old append-only file, so if the rewriting fails, we are safe)."
msgstr "親プロセスは、すべての新しい変更をメモリ上のバッファに蓄えます(同時に新しい変更は古いファイルに書き続けられるため、リライトが失敗した場合も安全です)。"

#: ../../source/topics/persistence.rst:267
# 4a73511a952643ce8a4e922c7b487b4b
msgid "When the child is done rewriting the file, the parent gets a signal, and appends the in-memory buffer at the end of the file generated by the child."
msgstr "子プロセスがリライトを完了したら、親はシグナルを受け取り、メモリ上のバッファを子プロセスが生成したファイルの末尾に書き出します。"

#: ../../source/topics/persistence.rst:271
# 580c43b5b0044fd19ffff6d497b1a8b3
msgid "Profit! Now Redis atomically renames the old file into the new one, and starts appending new data into the new file."
msgstr "Profit! Redis は古いファイルをアトミックに新しいファイルにリネームし、新しいファイルに追記を始めます。"

#: ../../source/topics/persistence.rst:275
# b2e0a4fc20614b69a2136f0bd0671f23
msgid "How I can switch to AOF, if I'm currently using dump.rdb snapshots?"
msgstr "現在 dump.rdb スナップショットを使っているが、AOF に変更するにはどうしたらいいか？"

#: ../../source/topics/persistence.rst:277
# 14c6c970f7da45368239286b52374215
msgid "There is a different procedure to do this in Redis 2.0 and Redis 2.2, as you can guess it's simpler in Redis 2.2 and does not require a restart at all."
msgstr "Redis 2.0 と 2.2 [訳注: 以降]で手順が異なります。2.2 のほうがシンプルで、再起動が必要ありません。"

#: ../../source/topics/persistence.rst:281
# ddb65daef5614307a419e1eeb8fbe4d7
msgid "**Redis >= 2.2**"
msgstr ""

#: ../../source/topics/persistence.rst:283
#: ../../source/topics/persistence.rst:306
# 68769dfc6ea6448f96e1f515a4303c09
# 6230bc8355a14f52b8782d3d0b94b98e
msgid "Make a backup of your latest dump.rdb file."
msgstr "直近の dump.rdb ファイルをバックアップします。"

#: ../../source/topics/persistence.rst:284
#: ../../source/topics/persistence.rst:307
# c25f49b86d474df1a6e9bbfa17cc271c
# c6429599f4d2454e85afd72d0dedf1a8
msgid "Transfer this backup into a safe place."
msgstr "バックアップを安全な場所に退避します。"

#: ../../source/topics/persistence.rst:285
# 9357a2f4373f48c393b55c22dbc02722
msgid "Issue the following two commands:"
msgstr "以下の 2 つのコマンドを発行します:"

#: ../../source/topics/persistence.rst:286
# fa26462daec74d0a8d667da748753f58
msgid "redis-cli config set appendonly yes"
msgstr ""

#: ../../source/topics/persistence.rst:287
# d650e094d5cb46ce81e94ea1f2b4f01c
msgid "redis-cli config set save \"\""
msgstr ""

#: ../../source/topics/persistence.rst:288
#: ../../source/topics/persistence.rst:314
# 37099a65b39a45bc85fd203dc355f936
# 3024e8b31b4c4076bb577ea417289c0b
msgid "Make sure that your database contains the same number of keys it contained."
msgstr "データベースが、[訳注: コマンド実行前と]同じ数のキーを含んでいることを確認します。"

#: ../../source/topics/persistence.rst:290
#: ../../source/topics/persistence.rst:316
# 1b0df3fac57d440cb7007fe616d06812
# 85a0f4a8dbb249c9a572204e33424d91
msgid "Make sure that writes are appended to the append only file correctly."
msgstr "書き込みが、追記専用ファイルに正しく書き出されていることを確認します。"

#: ../../source/topics/persistence.rst:292
# e0347b7fa6664a91b4f168450f36cf2c
msgid "The first CONFIG command enables the Append Only File. In order to do so **Redis will block** to generate the initial dump, then will open the file for writing, and will start appending all the next write queries."
msgstr "1 つめの CONFIG コマンドは、追記専用ファイルを有効にします。このとき、初期ダンプファイルを生成するために **Redis はブロックします** 。そして、書き込みのためにファイルをオープンし、以降の書き込みリクエストを追記し始めます。"

#: ../../source/topics/persistence.rst:296
# e856aee443cf4fdd9e3fe6e8b5dfd903
msgid "The second CONFIG command is used to turn off snapshotting persistence. This is optional, if you wish you can take both the persistence methods enabled."
msgstr "2 つめの CONFIG コマンドはスナップショット永続化を無効にしています。これはオプションで、両方の永続化メソッドを有効にしておくこともできます。"

#: ../../source/topics/persistence.rst:300
# 91c4627c6fae46e7bd981763c7a2efed
msgid "**IMPORTANT:** remember to edit your redis.conf to turn on the AOF, otherwise when you restart the server the configuration changes will be lost and the server will start again with the old configuration."
msgstr "**重要:** redis.conf で AOF の設定を有効にしておくことを忘れないでください。そうしないと、サーバーを再起動したときに設定の変更が失われ、古い設定で起動します。"

#: ../../source/topics/persistence.rst:304
# 84b5d5eb7f784ff0923738c3c573e51c
msgid "**Redis 2.0**"
msgstr ""

#: ../../source/topics/persistence.rst:308
# 61e873dbb2554e748de0742c90526b28
msgid "Stop all the writes against the database!"
msgstr "データベースへの書き込みをすべて停止しておきます！"

#: ../../source/topics/persistence.rst:309
# 8234c7c0ea604f888f89fb69793b631b
msgid "Issue a redis-cli bgrewriteaof. This will create the append only file."
msgstr "``redis-cli bgrewriteaof`` を発行する。これで追記専用ファイルが作成されます。"

#: ../../source/topics/persistence.rst:311
# 490bca12f59e4cc38ed4d5f1cc3e9cd3
msgid "Stop the server when Redis finished generating the AOF dump."
msgstr "Redis が AOF ダンプを完了したら、サーバーを停止します。"

#: ../../source/topics/persistence.rst:312
# 76c677090435437b9d24ee3ba02845bf
msgid "Edit redis.conf end enable append only file persistence."
msgstr "redis.conf を編集し、追記専用ファイルへの永続化を有効にします。"

#: ../../source/topics/persistence.rst:313
# e3528ec6b2494f159c7276e90ac71c23
msgid "Restart the server."
msgstr "サーバーを再起動します。"

#: ../../source/topics/persistence.rst:319
# 5214ea52475f4a3186a553c8b10258ba
msgid "Interactions between AOF and RDB persistence"
msgstr "AOF と RDB 永続化の相互作用"

#: ../../source/topics/persistence.rst:321
# fc5330243e2e4b79bcc359be97e4b331
msgid "Redis >= 2.4 makes sure to avoid triggering an AOF rewrite when an RDB snapshotting operation is already in progress, or allowing a BGSAVE while the AOF rewrite is in progress. This prevents two Redis background processes from doing heavy disk I/O at the same time."
msgstr "Redis 2.4 以降、RDB スナップショット操作がすでに実行中であれば AOF リライトトリガーを避け、また AOF リライトが実行中であれば BGSAVE は許可されません。これは 2 つのバックグラウンドプロセスが同時に走ることで、重いディスク I/O が発生することを避けるためです。"

#: ../../source/topics/persistence.rst:326
# bd529076d6a946139ddf2fa455e8f8e4
msgid "When snapshotting is in progress and the user explicitly requests a log rewrite operation using BGREWRITEAOF the server will reply with an OK status code telling the user the operation is scheduled, and the rewrite will start once the snapshotting is completed."
msgstr "スナップショット実行中に、ユーザーが明示的に BGREWRITEAOF を発行した場合、サーバーは OK ステータスコードを返します。ユーザーの操作はスケジューリングされ、スナップショットが完了したらリライトが開始されます。"

#: ../../source/topics/persistence.rst:331
# 825383f0b53c4f84ad0b29a91226f6af
msgid "In the case both AOF and RDB persistence are enabled and Redis restarts the AOF file will be used to reconstruct the original dataset since it is guaranteed to be the most complete."
msgstr "AOF と RDB の両方が有効化されている場合、Redis は再起動時に元データを復元する際、AOF ファイルを使用します。そのほうがより完全に近いことが保証されているためです。"

#: ../../source/topics/persistence.rst:336
# f2799a2ba4584dfea3b28761f30900fe
msgid "Backing up Redis data"
msgstr "Redis データのバックアップ"

#: ../../source/topics/persistence.rst:338
# 6b9bf45f26ec4049b93962fa55af462d
msgid "Before starting this section, make sure to read the following sentence: **Make Sure to Backup Your Database**. Disks break, instances in the cloud disappear, and so forth: no backups means huge risk of data disappearing into /dev/null."
msgstr "この説を読む前に、次のセンテンスを必ず読んでください: **データベースのバックアップを確実にとりましょう** 。ディスクは壊れるものであり、クラウド上のインスタンスは消失するものであり、その他もろもろ: バックアップをとらないことは、データを /dev/null へ送り込む大きなリスクを伴います。"

#: ../../source/topics/persistence.rst:343
# d6a78fec8fb240ea90ccc7ba7bdf8412
msgid "Redis is very data backup friendly since you can copy RDB files while the database is running: the RDB is never modified once produced, and while it gets produced it uses a temporary name and is renamed into its final destination atomically using rename(2) only when the new snapshot is complete."
msgstr "稼動中にRDB ファイルのコピーが取得できるため、Redis は非常にバックアップ・フレンドリーです: RDB は一度生成されると変更されません。また、書き込み中は一時的な名前[訳注: ファイル名]が使われ、スナップショットが完了した場合に初めて rename(2) によりアトミックにリネームされます。"

#: ../../source/topics/persistence.rst:349
# 1502ac4e5c15433fb9fdd0549ed41392
msgid "This means that copying the RDB file is completely safe while the server is running. This is what we suggest:"
msgstr "これは、サーバー稼動中に RDB ファイルをコピーしても完全に安全であることを意味します。以下は、推奨される方法です:"

#: ../../source/topics/persistence.rst:352
# dbfe704297774772b8b5aa120ca37e3e
msgid "Create a cron job in your server creating hourly snapshots of the RDB file in one directory, and daily snapshots in a different directory."
msgstr "あるディレクトリに、時間ごとの RDB ファイルのスナップショットを作成し、別のディレクトリには日ごとのスナップショットを作成する cron ジョブを用意する。"

#: ../../source/topics/persistence.rst:354
# ac22d0c8809a41939c5b99b88ced6bdc
msgid "Every time the cron script runs, make sure to call the ``find`` command to make sure too old snapshots are deleted: for instance you can take hourly snapshots for the latest 48 hours, and daily snapshots for one or two months. Make sure to name the snapshots with data and time information."
msgstr "cron スクリプトを実行する都度、 ``find`` コマンドを使って古いスナップショットを削除する: たとえば時間別のスナップショットは 48 時間分だけ残し、日別のスナップショットは 1 ヵ月ないし 2 ヵ月分だけ残す、など。スナップショットのファイル名には日時を入れましょう。"

#: ../../source/topics/persistence.rst:359
# a950fa1dc21b45c9931b8fab6e2740d4
msgid "At least one time every day make sure to transfer an RDB snapshot *outside your data center* or at least *outside the physical machine* running your Redis instance."
msgstr "少なくとも 1 日に 1 回は、 *データセンターの外* か、少なくとも Redis インスタンスが稼働している *物理マシンの外* へRDB スナップショットを転送しましょう。"

#: ../../source/topics/persistence.rst:364
# 3165905871634d2eb5a7b1423c53432d
msgid "Disaster recovery"
msgstr "災害時の復旧"

#: ../../source/topics/persistence.rst:366
# e792ab26cf4942dfa7d04d74042848ce
msgid "Disaster recovery in the context of Redis is basically the same story as backups, plus the ability to transfer those backups in many different external data centers. This way data is secured even in the case of some catastrophic event affecting the main data center where Redis is running and producing its snapshots."
msgstr "Redis において、災害時の復旧は、基本的にはバックアップと同義ですが、バックアップを異なる複数のデータセンターへ転送できるようにしておく、という点が加わります。こうしておくことで、何らかの壊滅的な被害が Redis が稼働しているメインのデータセンターに発生した場合でも、データは守られます。"

#: ../../source/topics/persistence.rst:372
# a8799c2fbca04063a8170bdba8efe8cb
msgid "Since many Redis users are in the startup scene and thus don't have plenty of money to spend we'll review the most interesting disaster recovery techniques that don't have too high costs."
msgstr "Redis を使っているユーザーの多くはスタートアップ環境にあり、多くの資金を持っていません。そのため、高コストすぎないリカバリーテクニックを見ていきます。"

#: ../../source/topics/persistence.rst:376
# 39882240e9554f299adff43e4ebe6a6d
msgid "Amazon S3 and other similar services are a good way for mounting your disaster recovery system. Simply transfer your daily or hourly RDB snapshot to S3 in an encrypted form. You can encrypt your data using ``gpg -c`` (in symmetric encryption mode). Make sure to store your password in many different safe places (for instance give a copy to the most important guys of your organization). It is recommanded to use multiple storage services for improved data safety."
msgstr "Amazon S3 やその他の類似サービスは、災害復旧システムを実装するにあたって良い選択肢です。単純に、日毎、または時間毎の RDB スナップショットを暗号化して S3 に転送してください。 ``gpc -c`` で暗号化することができます(共通鍵暗号方式)。パスワードを、複数の異なる安全な場所に保管しておきましょう(たとえば、あなたの組織でもっとも重要な人物にコピーを渡しておくなど)。より安全性を高めるなら、複数のストレージサービスを使うと良いでしょう。"

#: ../../source/topics/persistence.rst:383
# 9e69b15267e84b8a9825306f9a196bc2
msgid "Transfer your snapshots using SCP (part of SSH) to far servers. This is a fairly simple and safe route: get a small VPS in a place that is very far from you, install ssh there, and greate an ssh client key without passphrase, then make add it in the authorized\\_keys file of your small VPS. You are ready to transfer backups in an automated fashion. Get at least two VPS in two different providers for best results."
msgstr "SCP を使って遠隔のサーバーにスナップショットを転送してください。大変シンプルで安全な経路があります: 遠隔地に小さな VPS を用意し、SSH をインストールし、パスフレーズなしで SSH クライアントキーを生成し、公開鍵を VPS 上に配置します。これでバックアップを自動転送する準備が整いました。少なくとも 2 つの VPS を 2 つの異なるプロバイダ上に置いておくのが最良でしょう。"

#: ../../source/topics/persistence.rst:391
# 9f5527f53ab74ec8974dac2077e6445f
msgid "It is important to understand that this systems can easily fail if not coded in the right way. At least make absolutely sure that after the transfer is completed you are able to verify the file size (that should match the one of the file you copied) and possibly the SHA1 digest if you are using a VPS."
msgstr "このシステムは、正しく実装されなければ簡単に失敗してしまう、ということを理解しておくことが大事です。少なくとも転送完了後には、ファイルサイズを必ず検証してください(コピー元のファイルと一致するはずです)。もし VPS を使っているなら SHA1 ダイジェストも検証すると良いでしょう。"

#: ../../source/topics/persistence.rst:397
# ec9d5a7d36774dea9d39a3cb53dbb474
msgid "You also need some kind of independent alert system if the transfer of fresh backups is not working for some reason."
msgstr "また、最新のバックアップが何らかの理由で失敗していないか、独立した異常検知システムが必要になるでしょう。"

