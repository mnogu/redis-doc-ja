# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014, moco_beta
# This file is distributed under the same license as the Redis Documentation (Japanese) package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Redis Documentation (Japanese) 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-07-31 23:30+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/topics/faq.rst:2
# 76c3567aace445fa8de6706076d64c12
msgid "FAQ"
msgstr ""

#: ../../source/topics/faq.rst:5
# 9bebb23ccc20495e9d0383df95602b2c
msgid "Why Redis is different compared to other key-value stores?"
msgstr "Redis はなぜ他のキー・バリューストアと違うのか？"

#: ../../source/topics/faq.rst:7
# a921e800c0dc4623a89fce263f8e786c
msgid "There are two main reasons."
msgstr "それには 2 つの理由があります。"

#: ../../source/topics/faq.rst:9
# 9d1f4e965700440791bca3b5ec1255e6
msgid "Redis is a different evolution path in the key-value DBs where values can contain more complex data types, with atomic operations defined on those data types. Redis data types are closely related to fundamental data structures and are exposed to the programmer as such, without additional abstraction layers."
msgstr "Redis は、複雑なデータタイプをもつことができ、またそれらに対して定義されたアトミックな操作を備えている、という点で、他のキー・バリュー DB とは異なる進化を遂げてきました。Redis のデータタイプは基礎的なデータ構造と深い関わりをもち、付加的な抽象レイヤを介することなくプログラマに公開されています。"

#: ../../source/topics/faq.rst:14
# bf909607d4dc464bbaea17b78a0d0e09
msgid "Redis is an in-memory but persistent on disk database, so it represents a different trade off where very high write and read speed is achieved with the limitation of data sets that can't be larger than memory. Another advantage of in memory databases is that the memory representation of complex data structures is much simpler to manipulate compared to the same data structure on disk, so Redis can do a lot, with little internal complexity. At the same time the two on-disk storage formats (RDB and AOF) don't need to be suitable for random access, so they are compact and always generated in an append-only fashion (Even the AOF log rotation is an append-only operation, since the new version is generated from the copy of data in memory)."
msgstr "Redis はディスクにも永続化を行いますが、インメモリデータベースであり、そこにはトレードオフが存在します。つまり、メモリ容量より大きなデータ・セットを保持できない代わりに、高速な書き込みと読み込みを達成します。インメモリデータベースのもうひとつの利点は、複雑なデータ構造のメモリ表現は、同じ構造をディスクに格納するのに比較すると、よりシンプルに操作できる、というものです。そのため Redis は内部的な複雑さを抑えながら多くの仕事をします。同時に、 2 つのオン・ディスクのストレージフォーマット (RDB と AOF) はランダムアクセスに適している必要がなく、そのためコンパクトで、常に追記のみのスタイルで生成されます(AOF ログローテーションも、メモリ上のコピーから新しいバージョンが生成されるため、追記のみの操作で済みます)。"

#: ../../source/topics/faq.rst:28
# 48df069db0ab4ae9a82cca5f430a530e
msgid "What's the Redis memory footprint?"
msgstr "Redis のメモリ・フットプリントは？"

#: ../../source/topics/faq.rst:30
# 63b0dd6d5830427da6dcf479128ae345
msgid "To give you a few examples (all obtained using 64-bit instances):"
msgstr "いくつかの例を挙げます(すべて、64 bit インスタンスで測定したものです):"

#: ../../source/topics/faq.rst:32
# dac61216418c492c9fa28afb84f98e31
msgid "An empty instance uses ~ 1MB of memory."
msgstr "空のインスタンスは 1MB 以下のメモリを消費します。"

#: ../../source/topics/faq.rst:33
# 801a9a6978d24ba7a62e392f3e6c0138
msgid "1 Million small Keys -> String Value pairs use ~ 100MB of memory."
msgstr "100 万個の小さなキー -> 文字列値のペアは、 100MB 以下のメモリを消費します。"

#: ../../source/topics/faq.rst:34
# 2fc91e4a82ca47c19fd8d84f3f193314
msgid "1 Million Keys -> Hash value, representing an object with 5 fields, use ~ 200 MB of memory."
msgstr "100 万個のキー -> ハッシュ値(5 つのフィールドをもつ)のペアは、200MB 以下のメモリを消費します。"

#: ../../source/topics/faq.rst:37
# 895c52a04b444db6b9c7a26c23a45e3a
msgid "To test your use case is trivial using the ``redis-benchmark`` utility to generate random data sets and check with the ``INFO memory`` command the space used."
msgstr "あなたのユースケースで試すことも簡単です。 ``redis-benchmark`` ユーティリティを使ってランダムなデータ・セットを生成し、 ``INFO memory`` コマンドで使用量を確認してください。"

#: ../../source/topics/faq.rst:41
# 89a41e311bae46758cf219e350ede3b8
msgid "64 bit systems will use considerably more memory than 32 bit systems to store the same keys, especially if the keys and values are small, this is because pointers takes 8 bytes in 64 bit systems. But of course the advantage is that you can have a lot of memory in 64 bit systems, so in order to run large Redis servers a 64 bit system is more or less required. The alternative is sharding."
msgstr "64 bit システムは、32 bit システムよりも、同じキーを格納するために相当に大きなメモリを使います。とくにキーとバリューが小さな場合に顕著で、これは 64 bit システムではポインタに 8 byte 必要なためです。しかしもちろん、64 bit システムではより多くのメモリを使えるという利点があり、大きな Redis サーバーを運用するためには事実上 64 bit システムが必要です。別の手段としてはシャーディングがあります。"

#: ../../source/topics/faq.rst:49
# ca0bbeb2f7ff4368ab7dec36ea3d6e50
msgid "I like Redis high level operations and features, but I don't like that it takes everything in memory and I can't have a dataset larger the memory. Plans to change this?"
msgstr "私は Redis の高水準なオペレーションと機能が好きだが、すべてがメモリ上にあり、メモリより大きなデータセットを持てない、という点は気に入らない。この点を変える計画はあるのか？"

#: ../../source/topics/faq.rst:51
# c12b5fa9fdfe4b668608ac53f427a701
msgid "In the past the Redis developers experimented with Virtual Memory and other systems in order to allow larger than RAM datasets, but after all we are very happy if we can do one thing well: data served from memory, disk used for storage. So for now there are no plans to create an on disk backend for Redis. Most of what Redis is, after all, is a direct result of its current design."
msgstr "過去に、Redis 開発者は仮想メモリや他のシステムを使って、RAM よりも大きなデータ・セットを扱えるように試みたことがあります。しかし結局、私たちは 1 つのことをうまくやることで満足しています: データはメモリ上で提供され、ディスクはストレージとして使われる。今のところ、Redis のバックエンドにディスクを使う計画はありません。現在のデザインが Redis そのものなのです。"

#: ../../source/topics/faq.rst:58
# 0b38e240c2e545d4ae5c6365fb4bf083
msgid "If your real problem is not the total RAM needed, but the fact that you need to split your data set into multiple Redis instances, please read the `Partitioning page </topics/partitioning>`__ in this documentation for more info."
msgstr "もし、あなたの実際の問題が、必要とする RAM の量ではなく、複数の Redis インスタンスにデータ・セットを分割することなら、より詳しい情報のために `Partitioning <partitioning.html>`_ を参照してください。"

#: ../../source/topics/faq.rst:64
# f7dd10d0747c43598780510b584f39fb
msgid "Is using Redis together with an on-disk database a good idea?"
msgstr "Redis をオンディスク・データベースと一緒に使うことは良い考えですか？"

#: ../../source/topics/faq.rst:66
# c7122c7e412d48b5a22ba1a6dc5fc3cb
msgid "Yes, a common design pattern involves taking very write-heavy small data in Redis (and data you need the Redis data structures to model your problem in an efficinet way), and big *blobs* of data into an SQL or eventually consistent on-disk database."
msgstr "はい。一般的なデザインパターンとして、非常に書き込みの多い小さなデータ(と、あなたの問題を効率的にモデリングするために Redis のデータ構造を必要とするデータ)を Redis、大きな *blob* を SQL または結果整合性を担保するオンディスクデータベースに格納する、というものがあります。"

#: ../../source/topics/faq.rst:72
# 3353e4adb94b40578f10b09f91fcd33d
msgid "Is there something I can do to lower the Redis memory usage?"
msgstr "Redis のメモリ使用量を抑えるためにできることはありますか？"

#: ../../source/topics/faq.rst:74
# 22f155af7a424aec93b9fe0d47fa6f46
msgid "If you can, use Redis 32 bit instances. Also make good use of small hashes, lists, sorted sets, and sets of integers, since Redis is able to represent those data types in the special case of a few elements in a much more compact way. There is more info in the `Memory Optimization page </topics/memory-optimization>`__."
msgstr "可能なら、 32 bit の Redis インスタンスを使ってください。小さなハッシュ、リスト、ソート済みセット、integer からなるセットを活用してください。要素数が少ない特殊なケースの場合、Redis はよりコンパクトにこれらのデータタイプを表現します。詳しい情報は `メモリ最適化 <memory-optimization.html>`_ を参照してください。"

#: ../../source/topics/faq.rst:81
# 3e65400de38441bda75d7e97c1ddbd02
msgid "What happens if Redis runs out of memory?"
msgstr "Redis がメモリを使い切ったらどうなりますか？"

#: ../../source/topics/faq.rst:83
# 66ed3c7bbbbb4e8ab456b7ae04314734
msgid "Redis will either be killed by the Linux kernel OOM killer, crash with an error, or will start to slow down. With modern operating systems malloc() returning NULL is not common, usually the server will start swapping and Redis performances will degrade so you'll probably notice there is something wrong."
msgstr "Linux カーネルの OOM killer に kill されるか、エラーによりクラッシュするか、または性能が落ち始めるでしょう。最近のオペレーティングシステムでは、malloc() が NULL を返すことは稀で、サーバーはスワップを始めるために Redis の性能が落ちはじめ、何か問題が発生していることに気づくでしょう。"

#: ../../source/topics/faq.rst:89
# 8b9ab66fa77948c98d1030934ea95c81
msgid "The INFO command will report the amount of memory Redis is using so you can write scripts that monitor your Redis servers checking for critical conditions."
msgstr "INFO コマンドは Redis が使用しているメモリ量をレポートするため、致命的な状態のチェックのために、あなたの Redis サーバーをモニターするスクリプトを書くことができます。"

#: ../../source/topics/faq.rst:93
# a610adecfa854ab496f7f9d10b8cb023
msgid "Redis has built-in protections allowing the user to set a max limit to memory usage, using the ``maxmemory`` option in the config file to put a limit to the memory Redis can use. If this limit is reached Redis will start to reply with an error to write commands (but will continue to accept read-only commands), or you can configure it to evict keys when the max memory limit is reached in the case you are using Redis for caching."
msgstr "Redis はユーザーがメモリ使用量の制限を設定するための、ビルトインの保護機構を備えています。設定ファイルの ``maxmemory`` オプションを使って、Redis が使えるメモリを制限します。もしこの制限を超えたら、Redis は書き込みコマンドに対してエラーを返し始めます(ただし、読み出しのみのコマンドについては受付け続けます)。もしくは、キャッシュ目的で Redis を使用している場合は、最大メモリ制限に達したときにはキーを evict するように設定することも可能です。"

#: ../../source/topics/faq.rst:101
# f8f21f201d25497f97fa35774b514f1e
msgid "We have documentations you plan to use `Redis as an LRU cache </topics/lru-cache>`__."
msgstr "`Redis を LRU キャッシュとして使う <lru-cache.html>`_ にドキュメントされています。"

#: ../../source/topics/faq.rst:105
# 4d2d9701751946b2bd26d4a1c58774a1
msgid "Background saving is failing with a fork() error under Linux even if I've a lot of free RAM!"
msgstr "(Linux 環境で) 十分なフリー RAM があるのに、バックグラウンド・セーブが fork() エラーで失敗する！" 

#: ../../source/topics/faq.rst:107
# 6b7d014ad45d444b8b4d317212e98856
msgid "Short answer: ``echo 1 > /proc/sys/vm/overcommit_memory`` :)"
msgstr "端的な答え: ``echo 1 > /proc/sys/vm/overcommit_memory`` :)"

#: ../../source/topics/faq.rst:109
# a532ddd5759d486cac32194f29d04e0b
msgid "And now the long one:"
msgstr "そして、長い回答:"

#: ../../source/topics/faq.rst:111
# 5c711815e7954b15ab84e631b6e459ea
msgid "Redis background saving schema relies on the copy-on-write semantic of fork in modern operating systems: Redis forks (creates a child process) that is an exact copy of the parent. The child process dumps the DB on disk and finally exits. In theory the child should use as much memory as the parent being a copy, but actually thanks to the copy-on-write semantic implemented by most modern operating systems the parent and child process will *share* the common memory pages. A page will be duplicated only when it changes in the child or in the parent. Since in theory all the pages may change while the child process is saving, Linux can't tell in advance how much memory the child will take, so if the ``overcommit_memory`` setting is set to zero fork will fail unless there is as much free RAM as required to really duplicate all the parent memory pages, with the result that if you have a Redis dataset of 3 GB and just 2 GB of free memory it will fail."
msgstr "Redis のバックグラウンド・セーブの枠組みは、近代的なオペレーティングシステムの fork の copy-on-write セマンティックに依存しています: Redis の fork (子プロセスの生成) は、正確に親プロセスのコピーです。子プロセスは、 DB をディスクにダンプした後、終了します。理論上は、子供はコピーされる親と同じだけのメモリを使用しますが、実際には近代的なオペレーティングシステムの copy-on-write セマンティックの実装により、親子のプロセス同士は共通のメモリページを *共有* します。あるページは、子供もしくは親によって変更されたときに限り、複製されます。理論的には、子プロセスがセーブを実行している間にすべてのページが変更される可能性があるため、Linux は子プロセスがどのくらいのメモリを必要とするか、事前に知ることはできません。そのため、 ``overcommit_memory`` が 0 に設定されている場合、実際に複製される、親の全メモリページに相当するフリー RAM がないと fork は失敗するでしょう。たとえば、もしあなたが 3 GB の Redis データ・セットを持っていて、2 GB のフリー RAM しかないような場合です。"

#: ../../source/topics/faq.rst:126
# 4b585045ac5c4de6b6851b1810cf27e4
msgid "Setting ``overcommit_memory`` to 1 says Linux to relax and perform the fork in a more optimistic allocation fashion, and this is indeed what you want for Redis."
msgstr "``overcommit_memory`` を 1 に設定すると、Linux は その制限を緩和し、より最適な allocation 方針で fork を実行します。これは、あなたが Redis に求める動作と一致するでしょう。"

#: ../../source/topics/faq.rst:130
# 6205e61c8f054aecb518e33aedad216e
msgid "A good source to understand how Linux Virtual Memory work and other alternatives for ``overcommit_memory`` and ``overcommit_ratio`` is this classic from Red Hat Magazine, `\"Understanding Virtual Memory\" <http://www.redhat.com/magazine/001nov04/features/vm/>`__."
msgstr "Linux の仮想メモリがどのように動作するかと、``overcommit_memory`` および ``overcommit_ratio`` の他の選択肢について理解するための良いリソースとしては、Red Hat Magine からの古典があります。 `\"Understanding Virtual Memory\" <http://www.redhat.com/magazine/001nov04/features/vm/>`_"

#: ../../source/topics/faq.rst:136
# b76b140b27704b3a974be937b09aa130
msgid "Are Redis on-disk-snapshots atomic?"
msgstr "Redis のオンディスク・スナップショットはアトミックですか？"

#: ../../source/topics/faq.rst:138
# 610e212e0a0f4f999b4fdbd291b58e8c
msgid "Yes, redis background saving process is always forked when the server is outside of the execution of a command, so every command reported to be atomic in RAM is also atomic from the point of view of the disk snapshot."
msgstr "はい。Redis のバックグラウンド・セーブ プロセスは、常にサーバーがコマンドを実行していない間に fork されるため、RAM 上でアトミックに実行されるコマンドはディスク・スナップショットの点から見てもアトミックです。"

#: ../../source/topics/faq.rst:144
# ca4667a33a6a4b8ea5292ee2ded9ef40
msgid "Redis is single threaded, how can I exploit multiple CPU / cores?"
msgstr "Redis はシングル・スレッドで動作するが、マルチ CPU / コアを活用するにはどうすれば良いか？"

#: ../../source/topics/faq.rst:146
# 63788fff098c48f8ab70855ffdf79ef4
msgid "It's very unlikely that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance using pipelining Redis running on an average Linux system can deliver even 500k requests per second, so if your application mainly uses O(N) or O(log(N)) commands it is hardly going to use too much CPU."
msgstr "Redis は通常、メモリまたはネットワーク・バウンドであるため、CPU がボトルネックになることは非常に稀です。たとえば、平均的な Linux システムで動いている Redis でパイプライニングを使った場合、50 万リクエスト/秒 の性能を発揮します。そのため、あなたのアプリケーションが主に O(N) または O(log(N)) のコマンドを使うなら、CPU を使いすぎる、ということは起こりにくいです。"

#: ../../source/topics/faq.rst:152
# c4e277e6c9b04248ab2a005f295e56d3
msgid "However to maximize CPU usage you can start multiple instances of Redis in the same box and treat them as different servers. At some point a single box may not be enough anyway, so if you want to use multiple CPUs you can start thinking at some way to shard earlier."
msgstr "しかし、CPU 使用効率を最大化するために、複数の Redis インスタンスを同一マシン上に立てて、それぞれ独立したサーバーとして扱うことも可能です。いずれにせよどの時点かで、1 つのインスタンスでは十分ではなくなるかもしれません。もし複数の CPU を使いたい場合は、早い段階で何らかのシャーディングを検討すると良いでしょう。"

#: ../../source/topics/faq.rst:157
# a269cb2d4d2d4a448b49a5d4180c826b
msgid "You can find more information about using multiple Redis instances in the `Partitioning page </topics/partitioning>`__."
msgstr "複数の Redis インスタンスを扱うにあたっての詳しい情報は、  `Partitioning page <partitioning.html>`_ を参照してください。"

#: ../../source/topics/faq.rst:161
# 1d22bb6020a142a1820c5e8440525937
msgid "What is the maximum number of keys a single Redis instance can hold? and what the max number of elements in a List, Set, Sorted Set?"
msgstr "1 つの Redis インスタンスは最大いくつまでキーを持てますか？また、リスト、セット、ソート済みセットがもてる最大要素数はいくつですか？"

#: ../../source/topics/faq.rst:163
# 0bc7f5639bd74cea83f91a8d2fb1ca33
msgid "Redis can handle up to 2^32 keys, and was tested in practice to handle at least 250 million of keys per instance."
msgstr "Redis は 2^32 個までのキーを扱えます。現実的には、インスタンスごとに少なくとも 2 億 5000 万個 のキーを扱えることがテストされています。"

#: ../../source/topics/faq.rst:166
# b85f02d371614461811a64a0664beb4b
msgid "Every list, set, and sorted set, can hold 2^32 elements."
msgstr "各リスト、セット、およびソート済みセットは 2^32 個の要素を格納できます。"

#: ../../source/topics/faq.rst:168
# 82f9bbe0e8d14983aa0319b4058d4e39
msgid "In other words your limit is likely the available memory in your system."
msgstr "言い換えると、限界はシステムで利用可能なメモリ量による、といえます。"

#: ../../source/topics/faq.rst:171
# 3e0e0910aecf46ab892c972c47e0cad3
msgid "My slave claims to have a different number of keys compared to its master, why?"
msgstr "スレーブが保持するキーの数が、マスターが保持するキーの数と異なります。なぜでしょうか？"

#: ../../source/topics/faq.rst:173
# aa8c04d76c974031a77505619eb36384
msgid "If you use keys with limited time to live (Redis expires) this is normal behavior. This is what happens:"
msgstr "もしキーに time to live (Redis expires) が設定されていたら、これは正常な振る舞いです。何が起こっているか:"

#: ../../source/topics/faq.rst:176
# a20b7aaf25054068b037cdeab053cbd1
msgid "The master generates an RDB file on the first synchronization with the slave."
msgstr "マスターは、スレーブとの初期同期時に RDB ファイルを生成します。"

#: ../../source/topics/faq.rst:178
# 7cd6c848f91d4cf2974c81d11779ec58
msgid "The RDB file will not include keys already expired in the master, but that are still in memory."
msgstr "RDB ファイルは、マスタ上ですでに expire されているが、まだメモリ上には存在しているキーを含みません。"

#: ../../source/topics/faq.rst:180
# 6704cc7c01fd47c6b4ab411d5bee2984
msgid "However these keys are still in the memory of the Redis master, even if logically expired. They'll not be considered as existing, but the memory will be reclaimed later, both incrementally and explicitly on access. However while these keys are not logical part of the dataset, they are advertised in ``INFO`` output and by the ``DBSIZE`` command."
msgstr "これらのキーは、論理的には expire されていても、Redis マスターのメモリ上にはまだ存在しています。これらは存在しているとは考慮されず、使用しているメモリ領域はインクリメンタルに、または明示的なアクセス時に再利用されます。これらのキーはデータ・セットの論理的な一部ではありませんが、 `INFO <http://redis.io/commands/info>`_ コマンドおよび `DBSIZE <http://redis.io/commands/dbsize>`_ コマンドでは通知されます。"

#: ../../source/topics/faq.rst:185
# 57fd05c84f664c7ba387cca261f25642
msgid "When the slave reads the RDB file generated by the master, this set of keys will not be loaded."
msgstr "マスターにより生成された RDB ファイルをスレーブが読んだとき、これらのキーはロードされません。"

#: ../../source/topics/faq.rst:188
# dbd700ede76948dfa05cd395699313cc
msgid "As a result of this, it is common for users with many keys with an expire set to see less keys in the slaves, because of this artifact, but there is no actual logical difference in the instances content."
msgstr "この作用の結果、多くの expire されたキーが存在するケースにおいて、スレーブ上では少ないキーしか存在しない、ということは一般的にあります。しかし、インスタンスが保持する内容に論理的な差異はありません。"

#: ../../source/topics/faq.rst:193
# 6f8986f32ec44d28b6c1bccc181997a7
msgid "What Redis means actually?"
msgstr "Redis とはどういう意味ですか？"

#: ../../source/topics/faq.rst:195
# 41a7ed31fdf44b15a4ad2e932d562f7b
msgid "It means REmote DIctionary Server."
msgstr "REmote DIctionary Server を意味しています。"

#: ../../source/topics/faq.rst:198
# 2f3c210a54ab4c08aee7104cbdad2d06
msgid "Why did you started the Redis project?"
msgstr "なぜ Redis プロジェクトを始めたのですか？"

#: ../../source/topics/faq.rst:200
# 574532f2efcd4a1ab28964f324418aac
msgid "Originally Redis was started in order to scale `LLOOGG <http://lloogg.com>`__. But after I got the basic server working I liked the idea to share the work with other guys, and Redis was turned into an open source project."
msgstr "もともとは、Redis は `LLOOGG <http://lloogg.com>`_ をスケールさせるために始まりました。しかし基本的な動くサーバーができた後、私は他の仲間とこの仕事を共有する、という考えを気に入り、Redis はオープンソース・プロジェクトへと発展しました。"
